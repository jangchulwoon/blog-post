---
layout: post
title:  OOP-Book-Review-2.4
tags: Study 
categories: OOP  
---   

이번글은 Interface Segregation Principle에 대한 글 입니다.
책에서는 C++을 갖고 설명을 했기에, Java로 설명된 블로그를 읽고 정리했습니다.

> 책의 내용과는 조금 거리가 있을 수 있습니다.  

#### 인터페이스 분리의 원칙   

ISP를 한 문장으로 설명하면 아래와 같습니다. 

    클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙

조금 더 쉽게 설명하자면, Interface를 너무 크게 만들지 말라는 원칙입니다.

> Interface가 커질 경우, 하위 구현 클래스들은 사용하지 않는 메서드가 발생할 수 있습니다.   

#### 예제    

> 제가 Iphone X를 사고 싶으니 .. Iphone 예제를 작성해보겠습니다. 

(Iphone 6 이후 ~ ) 아이폰X 이전에는 지문인식과 비밀번호 입력을 통해 암호를 풀 수 있었습니다. 

    Interface Iphone{
        boolean perceiveFingerprint()
        boolean enterPassword();
        ..... // 그 외 기능 
    }

Iphone X를 출시하면서 얼굴인식 방식이 추가되었습니다. 
얼굴 인식을 기존 Interface에 추가시켰다 라고 가정해봅시다.

    Interface Iphone{
        boolean perceiveFingerprint()
        boolean enterPassword();
        boolean perceiveFace();
        ..... // 그 외 기능 
    }


문제는 Iphone6/7은 perceiveFace 함수를 지원하지 않습니다. 
> 결국 해당 함수는 빈 값을 갖거나, UnsupportedException을 뱉게 되겠죠 ..

위 예시는 전형적인 ISP를 어긴 원칙입니다. 
너무 큰 Interface로 설계된 경우, 구현 클래스에서 사용되지 않는 함수가 있을 수 있습니다. 
이는 SRP와 유사한 원칙인데요. Interface 관점에서의 책임을 분리했다라고도 볼 수 있습니다.  

#### 정리하며    

사실 책에서는 다른 언어를 갖고 비유를 했기에, 책과는 거리가 먼 내용일 수 있습니다. 
> 조금 가벼운 내용인거 같기도 하구요 ...

피드백은 환영입니다 ~~ 
