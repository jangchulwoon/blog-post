#### 익명함수  

이전에 말했듯, js는 함수를 저장하고 변수처럼 사용 가능하다.

> first citizen 

이 특성을 이용해 callBack 함수를 재밋게(?) 이용할 수 있다.

--- 

    array.filter(function(v){
        return v < 10;
    }).reduce().~();

행위 자체를 넘겨 유연한 코드를 작성할 수 있다. 

---

#### 익명함수와 재귀의 결합   

재귀는 수학적인 측면에서 유용한 기법(?)이다. 
다만, 익명함수와 재귀가 결합하면 이상한 현상을 볼 수 있다.

> 사실 서비스 코드에서 재귀를 본적이 거의 없다.. 

--- 

    var recrusive = function(){ console.log('call'); return recrusive();}

위와같은 코드를 실행했을 때, 아무런 문제 없이 잘 동작한다. 
다만 문제는 참조하고 있는 함수를 넘긴후, 변수를 초기화할 경우 발생한다. 

--- 

    var recrusive = function(){ console.log('call'); return recrusive();}
    var realRecrusive = recrusive;
    recrusive = {};
    realRecrusive(); // error ! 

이유는 함수내에서 변수를 직접 가르키고 있기 때문입니다. 

--- 

#### 해결법 1. this 

말 그대로 this를 사용한다. 
함수 내부에서 this를 이용해 직접 참조합니다. 

> 문제점. this 마저도 위 방법과 동일하게 참조가 사라질 수 있다. 

---

#### 해결법 2. 이름있는 익명함수 사용 

var recrusive = function name(){ console.log('call'); return name();}
    
위와같이 익명함수에 이름을 붙이면 문제점이 해결됩니다.
또한 name이라는 함수를 호출할 수 있는 것은 자기 자신밖에 없습니다.

> 함수 이름에 대한 스코프는 자기 자신으로 정의 됩니다. 

---

#### 개인적인 생각 

좋은 내용이고, 이름있는 익명함수 라는 처음보는 형태를 알게되어 신기하지만 ..
딱 그정도까지 .. 재귀를 쓸일이 있나 ? 
(아직은 없었는데 .. )

> 이야기 해보죠 

--- 

#### 메모이징 기법 

클로저를 이용하던, 다른 방법들을 이용하던 해서 cache라는 변수를 만들고,
거기에 메모이징을 할 수 있습니다.

이 부분 역시, 읽으면서 이야기를 해보고 싶었는데요.
팀 내에 Js로 메모이징하는 경우가 많지 않아서요. 
(개인적으론 결과가 자주바뀌기 때문에 
client단에선 안하는게 맞다고보는데, 다른 분들 생각이 궁금합니다.)

--- 

#### overloading    

arguments를 이용하여 overloading `처럼` 보이게 할 수있습니다.

> 다만, 이게 overloading인지는 조금 의문이 드네요. 

가독성이 떨어질 뿐더러 차라리 이렇게 사용할 바엔, obj로 넘기는게 좋지 않을까 싶습니다.
(개인적인 생각이라, 다른분들의 의견도 궁금하네요)

---

#### 5장 클로저  

함수가 속해있던 유효범위에 접근 가능하다는 개념
심지어, 그 범위가 반환 된 것처럼 보여도 접근 가능 

> 참조가 없을때 GC에 의해 사라지기에, 반환 된것처럼 보인다고 표현함

---

#### 사용처 

1. private 
2. callback
3. currying
4. 함수 래핑
5. 즉시실행 

--- 

#### private 과 즉시실행 

모듈패턴을 이용해 공개하고 싶은 것들만 리턴하여 사용가능.
주로, 내부동작을 감추고 실행단위를 묶을 때 많이 사용하고 있음

> 즉시실행과 함께 사요앟는 경우가 많다.

---

#### callback  

promise처럼 이미 함수가 반환됐음에도 callback을 이용하여 변수에 접근할 수 있습니다.

#### 함수 래핑 

에러 코드 및 결과값을 클로저를 이용해 wrapping하여 사용가능합니다. 

#### currying 

defaut인자를 설정하고 함수를 리턴하는 방식으로 사용합니다.

> 위 3개는 굳이 클로저의 개념을 알지 않아도 사용하는데 문제없기에 간단히 설명했습니다.

---

#### 마무리 

클로저 부분은 중요한 부분임에도 어느정도 알고있는 내용을 다뤘습니다.
만약 CG의 동작방식이나, 내부에서 참조가 없음을 어떻게 판단하는가 에 대해 다뤘으면 
좋았을거같다는 생각...을 하고 있습니다.

(위 개념중 이해안가는 부분이 있으면 함께 다뤄보죠 ) 





