---
layout: post
title:  GraphQL에 대하여
tags: GraphQL 
categories: GraphQL
---   




브라우저에 의존성이 있는 SSE보다, GraphQL 이라는걸 스터디해보라는 피드백을 받아 해당 내용에 대해 스터디한 내용을 정리해봤습니다. 우선 사용법보다 왜 GraphQL이 등장했고, 어떤 개념인지에 대해 스터디를 진행했습니다.     
 
 
> 단순히 컨셉에 대한 글을 작성했습니다.    

#### 들어가며...       

GraphQL이라는 말만 들었을 때, SQL 같은 느낌을 받으면서 DataBase와 함께 사용될거라고 예상했습니다. 그래서 HTTP Client가 DB 쿼리도 만들어야되는 시대가 왔구나 생각했죠. 

~~드디어 서버개발자가 SQL을 사용하지 않아도 되는구나 !~~    

> 아니였습니다...   
 
GraphQL은 Client가 Server에게 데이터를 요청할때 이용하는 **API의 Query language** 입니다. 한줄로는 이해하기 어려워, Google에 GrapgQL을 검색해봤습니다. 많은 글들이 있지만 특히 [[112]rest에서 graph ql과 relay로 갈아타기 -  이정우](https://www.slideshare.net/deview/112rest-graph-ql-relay)라는 글이 눈에 띄었고, 

단순히 글 목록만 봤을 떄 GraphQL은 ...  

	REST는 ' 어떤 ' 문제점이 존재하고, GraphQL로 해결 할 수 있다.   

라고 추측됩니다.     

#### REST의 단점     

**1. 너무 많은 EndPoint**    

Rest를 이용해 URI을 관리하다보면 너무 많은 EndPoint를 갖고있는 Controller를 볼 수 있습니다. 많게는 한 Controller에 10개 이상의 EndPoint를 갖고있는 Class를 본 적이 있습니다. 

> 물론 설계를 잘 했다면 이러한 문제를 줄일 수는 있지만, 결국 언젠가는 마주칠 문제라고 생각합니다. 

이렇게 많은 EndPoint는 관리하기가 힘들뿐더러 각각의 EndPoint가 어떤 데이터를 주는지 알기 힘듭니다.    

**2. Data 의 모호성**     

(1.)의 내용과 이어지는 내용으로, Client 개발자는 request에 대한 response로 어떤 Data가 포함되어 있는지 알 수 없습니다. 포함되어있는 Data를 알기위해 명세를 본다거나 직접 요청을 날려서 확인을 해봐야 합니다. 또한 받는 Data를 선택 할 수도 없습니다. 

> 즉 Client 개발자는 Server에서 정해진 Data 양식을 받아서 처리할 수 밖에 없습니다.   

만약 추가적인 Data가 필요할 경우 Server 개발자에게 요청하여 명세를 바꿔야합니다. 즉, Client/Server 개발자 모두 번거로운 문제가 발생하죠. 

> REST는 너무 정적인 **Spec** 입니다 ...   


**3. 다중 요청**    

한 페이지에 3개 이상의 API를 사용하여 페이지를 구성할 경우, 최소 3번의 Request를 필요로하게 됩니다. 

> 이는 모바일 환경에서 메모리 낭비를 유발합니다.    

이와같은 문제점 외에도 다양한 요구들이 발생했고, 때문에 FaceBook은 2015년 GraphQL이라는 Sepct을 발표합니다.

(+) 현재는 많은 커뮤니티들이 해당 스펙을 관리(?)하고 있다고합니다.   

#### GraphQL !    

> [GraphiQL](https://graphql-tryout.herokuapp.com/graphql)로 예제를 진행 할 수 있습니다.

  
#### GraphQL의 기본 Schema   

GraphQL은 크게 Query 와 Mutation이라는 Schema로 구성되어져 있고, 각각은 다음과 같은 특성을 갖습니다. 

#### Query     

Query는 HTTP의 GET Method와 유사한 작업을 하는 함수입니다. 즉 Data를 요청하는 함수로, 아래와 같이 사용할 수 있습니다. 

	query{
	  accounts {
	    id
	    username
	    email
	  }
	}



> 해당 요청에대한 응답은 다음과 같습니다.    

	{
	  "data": {
	    "accounts": [
	      {
	        "id": "1",
	        "username": "velopert",
	        "email": "public.velopert@gmail.com"
	      },
	      {
	        "id": "2",
	        "username": "jn4kim",
	        "email": "jn4kim@gmail.com"
	      },
		  ..... 
	}  

GraphQL은 기본적으로 하나의 EndPoint에 query를 보내는 것을 권장하고, json과 유사한 구조로 요청을 보낼 수 있습니다.  
위와같이 GraphQL을 사용하면 조금더 명확한 Data를 가져올 수 있습니다. 

> 해당 EndPoint가 제공하는 Data 중, Client 개발자는 선택적으로 Data를 가져올 수 있습니다.     

또한 2가지 이상의 요청도 가능합니다!      

	query{
		accounts {
			id
			username
			email
		}
		# 특정 ID의 정보를 가져오는 Query
		account(id : "1") {
			id
			username
			email
	  	}
	}
	
위 요청은 accounts의 정보 중 id , username, email과 1번 사용자의 정보를 가져와 달라는 로직입니다. 즉, 기존 REST에서는 2번 요청했어야할 데이터를 1번으로 축소하여 가져올 수 있습니다.  

> 추가적으로 query는 생략해도 정상적으로 작동합니다 ! 

	{
	  accounts {
	    id
	    username
	    email
	  }
	}


만약 동일한 구조의 데이터를 2번이상 호출할 경우, 조금더 명확히 보기 위해 Aliases를 제공합니다 .

	query{
		accounts {
			id
			username
			email
		}
		# 특정 ID의 정보를 가져오는 Query
		myUser : account(id : "1") {
			id
			username
			email
	  	}
	}



#### Mutation 


Mutation은 Query와 다르게 생략이 불가능하며, 일반적으로 Data를 수정하는 역할을 진행합니다. HTTP와 달리 Delete, Put 등으로 나누지 않고 Mutation 내부에 구현한 함수로 해당 역할을 수행합니다.    

다음과 같이 사용됩니다.  

	mutation{
	  createAccount(username : "JCW" ,email : "email") {
	    id
	    username 
	    email
	  }
	}


> 해당 예제에서는 createAccount함수의 반환값이 Account (일종의 Object)이기에 세부 Type을 명시했습니다.   

Mutation은 Server측에서 제공하는 함수를 이용해서 Data를 조작하는 기능을 제공합니다.

> API 서버에서 사용자가 직접 Data를 수정하는 일은 빈번하지 않다고 생각하여, 해당 부분에 대해서는 깊게 학습하진 않았습니다. 간단한 컨셉정도만 학습을 진행했습니다.   


#### 그 외 ..     

 
추가적으로 Server 측에서  Schema를 구성하는 방법에는 2가지, 언어를 통한 구현과 별도의 파일에서 구현하는 방법(IDL)이 존재합니다.  

> 언어로 구현하는 방법    

	GraphQLObjectType fooType = newObject()
    .name("Account")
    .field(newFieldDefinition()
            .name("id")
            .type(GraphQLString))
    .build();

> IDL 을 이용한 방법 


	type Account {
	    id : String
	}

	type Query { 
		hotTopic : [Topic]
	    categoryTopic : [Topic]
	}



> IDL 파일을 이용해 별도로 관리하는 것이 낫다고 판단하여 IDL 방법을 사용했습니다.   


(+)    

GraphQL의 간단한 Flow를 설명하자면 다음과 같습니다.  

Server는 reqeust를 받으면 해당 요청의 유효성 검사를 진행합니다. 해당 함수 및 인자를 지원하는가를 판단하고, 지원 할 경우 함수를 실행하여 결과를 반환하게 됩니다.  

> Query 및 Mutation 에서 제공할 함수들을 별도의 Method로 관리해야 합니다.   



#### 개인적으로 했던 오해   

##### graphQL을 사용하면 SSE 등의 spec을 사용하지 못할 것이다.

간단하게 개념들을 학습하고 Servelt 위주의 몇가지 예제를 사용해보면서, GraphQL이 Spring 같은 프레임워크 라는 오해를 하게되었습니다.  ~  
  


##### Query는 자동적으로 Batch 처리를 해준다.    
   

     




    
####  참고    
     
[Basics Tutorial - Introduction](https://www.howtographql.com/basics/0-introduction/)