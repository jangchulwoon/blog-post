---
layout: post
title: Promise에 대하여
tags:  Js promise
categories:  Js
---    

         
Javascript를 사용하다보면 비동기로 서버측에 정보를 요청하는 '$.ajax'를 자주 볼 수 있습니다. 

	$.ajax({
		  method: "GET",
		  url: "/",
		  success : function(data) {
        	alert("success!");
    	}
	});

요청을 보내고, 성공시 success message를 보여주는 로직입니다. 단순히 1~2개의 요청을 보낸다고 하면 큰 문제는 없습니다. 다만, 다수의 비동기에서 선/후 관계가 생긴다면 콜백지옥을 볼 수 있습니다. 
 
	//선행
	$.ajax({
		  method: "GET",
		  url: "/",
		  success : function(data) {
	    	alert("success!");
			// 후행
			$.ajax({
				  method: "GET",
				  url: "/",
				  success : function(data) {
		    		alert("success!");
				}
            })
		}
    }); 

> 실제로 이렇게 쓴 코드는 본적이 없지만 ...     

위 방식은 콜백지옥을 보일 뿐더러, 코드를 읽기 어렵습니다.     
기존 ajax방식에는 또 하나의 단점이 존재합니다. 바로 예외처리에 대한 부분이죠.      

> ajax의 success 부분에서 throw를 던져도 특별한 처리를 할 수 없습니다.  

	$.ajax({
		  method: "GET",
		  url: "/",
		success : function(data) {
        	alert("success!");
    		throw "에러";
			alert("?");
		},
		error  : function(){
    		alert("???");
		}
	});   

위 코드를 작성했던 의도는 throw를 통해 error의 코드를 실행하는 것입니다. 하지만, 의도한 바와는 달리 작동하는데, 그 이유는 error은 예외 처리를 하는 인자가 아닌, 비동기 통신이 실패할때 실행되는 코드입니다.      

> 그럼 ajax에서 예외처리를 도와주는 인자는 무엇일까요  ?       

 [ 이 부분은 조금 더 찾아볼 것 ]   

https://blog.coderifleman.com/2014/11/15/javascript-and-async-error/

### Promise 개념         

기존 비동기 방식은 예외처리와 콜백지옥에 대한 단점이 존재했습니다. 이를 해결하기위해 등장한 패턴(?)이 Promise를 사용한 패턴 입니다.      

> Promise란 비동기 처리를 **추상화**한 객체로, 이를 이용해 비동기를 처리 할 수 있습니다.    

정말 사전적인 의미이지만 중요한 부분은 **추상화** 라는 단어 입니다.      
추상화를 했다는 것은, Promise를 사용하는 모든 객체의 틀이 잡혀있다는 의미로 비동기 처리를 패턴화 할 수 있다는 장점을 갖고 있습니다.       

> 즉, promise를 재정의 하더라도, 정해진 함수만 사용할 수 있습니다.      


### Promise 사용      

	var promise = new Promise(function(resolve, reject){});    

promise는 위와같이 사용 할 수 있습니다.  resolve 는 성공했을 때, reject는 실패했을 때 실행되는 함수입니다. 

	var promise = new Promise(function(resolve, reject){
		if(true){
			resolve("성공");
		}
		reject("실패");
	});    

	promise.then(function(data){ console.log(data)});


> 출력 결과 > 성공      

성공시 resolve의 함수의 인자를 then()의 인자로 넘겨주게 됩니다. 물론 실패도 마찬가지 방식으로 동작합니다.    
   
	promise.then(onFulfilled, onRejected); 

then 함수를 이용하면, 성공시 onFulfilled, 실패시 onRejected를 수행하게 됩니다.   
이때 promise에서 정의한 resolve 와 reject 의 인자를 넘겨주어 처리 할 수 있습니다.    


**추가적으로**

Promise를 직접 new로 생성하는 방식 이외에도, 
	
	var promise = Promise.resolve();    

이와같이 promise를 생성할 수 있습니다.     

> 위와같이 생성하면 asyn 환경에서 예상치 못한 동작을 수행한다고 합니다.     
> 이 부분은 이해가 부족하여 더 학습 후 정리하겠습니다.
[링크](http://han41858.tistory.com/11)          

    

### 예외 처리    

Promise에서는 예외처리를 지원하는데, 만약 throw가 발생한다면 다음과 같이 코드를 작성하면 됩니다.   

	var promise = new Promise(function(resolve,reject){
		if(true){
			resolve(function(){
				alert("test");
				throw "error";
			});
		}
		reject("error");
	});
	
	promise.then(function(success){
		success();
	}, function(fail){
		fail();
	}).catch(function(message){
		console.log(message);
	});   


해당 함수는 resolve의 인자로 함수를 넘겨주는데, 그 안에서 throw를 발생시킵니다.  이때 기존 ajax의 success 부분이라면, error 코드로 넘어가는 것이 아닌, 함수 자체를 끝내버립니다. 
promise는 ajax와는 달리,  throw가 발생하면 catch로 인자를 넘겨 처리 할 수 있습니다. 

즉, Promise는 throw 처리를 지원합니다.    
 
> 출력결과 : alret("texst") - > console :: error     



#### 상태     

promise는 4가지중 한가지의 상태를 갖습니다.      

pending     -> 막 초기화된 상태   
fulfilled -> 성공한 상태       
rejected   -> 실패한 상태     
settled  -> 완료한 상태      


> 사실 이 상태가 무엇을 의미하는지 이해하진 못했습니다.     
> 추즉하건데 이 상태를 통해, promise의 진행상황을 알 수 있는것 같습니다.    
> 정확하진 않습니다 !      



#### 정리      

Promise는 콜백지옥을 완화 시킬 수 있을 뿐더러, catch를 통해 예외 처리또한 가능합니다. 
나아가 promise를 반환하는 객체들을 이용하면 쉽게 chaining을 사용 할 수 있습니다.  

> 모두들 Promise 쓰세요 .. !          



참조      

[[JavaScript] 바보들을 위한 Promise 강의 - 도대체 Promise는 어떻게 쓰는거야?](http://programmingsummaries.tistory.com/325)      

08-03       
lusiue@gmail.com       

사실 아직은 써봐라 이러면 못쓸거 같긴합니다...     

추가적으로 setTimeout 과 promise를 연결해서 사용해보려합니다.   
아직 예상치 못한 에러를 발견해서 내일 중으로 정리해 보겠습니다.      

~ 