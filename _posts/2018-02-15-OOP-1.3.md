---
layout: post
title:  OOP-Book-Review-1.3
tags: Study 
categories: OOP  
---   

데미테르의 법칙(Law of Demeter)은 Tell, Don't Ask를 만족시키기 위해 함께 설명되는 법칙입니다. 사실 이전 글에서 봤던, 집배부 예시가 데미테르를 설명하는 가장 유명한 예시라고 합니다. 

(주의) 이번 글은 다소 원론적 일수 있습니다 ..  

#### 데미테르의 법칙   

데미테르의 법칙의 목적은 모듈들 사이 혹은, 객체 간의 관계에 있어 결합도를 줄이는 것입니다. 
OOP의 목적과도 일치하네요 :D  

데미테르를 만족시키기 위한 조건들은 다음과 같습니다. 

> 어떤 객체 o에 대해서, o의 메서드 m은 다음과 같은 객체의 메서드만을 실행시킬 수 있다. 

    1. o 자체의 메서드
    2. m의 변수
    3. m안에서 만들어진 객체
    4. o가 직접 관리하는 컴포넌트 객체
    5. m scope안에서 o가 접근 가능한 전역변수 

위 법칙을 지키면 기본적으로 Tell, Don't Ask 를 지킬 수 있고, 결합도를 어느정도 줄일 수 있다고 말합니다. 
책에서는 이를 조금더 쉽게 설명해 두었는데요. 

    1. 메서드에서 생성한 객체의 메서드만 호출
    2. 파라미터로 받은 객체의 메서드만 호출
    3. 필드로 참조하는 객체의 메서드만 호출 

입니다 ..... ~~뭐가 더 쉽다는건지 ..~~

이전 예제를 다시 끌고오자면, 

	public class PaperBoy {
	
		public void receiveOrder(Customer customer){
			int price = 1000;
			Wallet wallet = customer.getWallet();
			
			if(wallet.getTotalMoney() > price){
				wallet.subtractMoney(1000);
			}else {
				// 돈이 없습니다.
			}
		}
	}

위 코드는 데미테르 법칙을 어기고 있습니다. 파라미터로 받은 객체의 메서드만 호출해야하는데, 파라미터의 객체로 부터 Wallet객체를 반환받아 getTotalMoney()를 호출하기 때문입니다. 
만약 지갑이 아닌 주머니에서 돈을 꺼낸다거나, 카드로 결제를 진행한다고 하면 custom객체 뿐만 아니라 paperBoy 객체의 코드도 변경이 일어납니다. 이 코드는 책임이 적절히 분배되지 못한 케이스이며 변경에 열려있다고 볼 수 있습니다. 

#### 마치며   

이 처럼 접근 가능한 객체로부터 새로운 객체를 반환 받은 뒤, 그 객체로 연산을 하는 것은 결합도를 올리는 행위입니다. 
데미테르 와 Tell,Don't Ask는 이를 피하기 위한 가이드라인일 뿐, 사실 그동안 이렇게 개발을 해왔다면 굳이 (억지로)머리아프게 볼 필요는 없습니다.  
다만, 법칙의 탄생 배경과 이를 해결하기 위해 어떤 방식을 사용했는지 정도는 알아두면 좋을것 같습니다 :D

> 객체가 아닌, Static Method Factory일 경우는 객체로 호출하지 않기에 위 법칙과는 거리가 있을거라 생각됩니다. 

지금까지 글들은 OOP와 객체에 대한 가이드라인을 설명했습니다. 절차지향과 객체지향의 차이와 객체지향의 목적에 대해 언급하면서 객체의 책임, 메시지 , 협력관계에 대해 설명하고, 또한 캡슐화 / Tell, Don't Ask / 데미테르의 법칙등을 이용하여 책임을 분리하여 결합도를 떨어뜨리는 방법에대해서도 언급합니다. 

또한 객체 지향의 설계에 대해서도 짧게 언급하는데, 설계가 한번에 되는 것이 아닌 점진적으로 이루어진다고 말합니다.

	1. 프로젝트의 구현 사항을 세분화하고, 알맞은 객체에게 기능을 할당한다.
	2. 연관된 객체간의 어떻게 메시지를 주고받을지 결정한다.
	3. 위 사항을 반복한다. 

이전 글들에서 알 수 있듯이, (위 과정에서) 올바른 객체에게 책임을 분배해야하고, 캡슐화를 이용해 결합도를 최대한 줄이는 노력이 필요합니다. 

이번 챕터는 조금 원론적인 이야기를 설명했습니다. 이 책을 읽는다고해서 코딩실력이 퐉! 늘진 않겠지만 개발을 하면서 간과했던 점들을 일깨워준 챕터였습니다. 

> 생각 할 수 있는 범주를 늘려준 것 같습니다.  

책을 정리하면서 꽤나 재밌었고, 그동안 생각했던 OOP에 대해 윤곽선을 그릴 수 있었던 좋은 경험이였습니다. 
멈추지않고 정리해보도록 하겠습니다 .. 


