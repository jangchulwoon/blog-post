---
layout: post
title:  OOP-Book-Review-1.3
tags: Study 
categories: OOP  
---   

데미테르의 법칙(Law of Demeter)은 Tell, Don't Ask를 만족시키기 위해 함께 설명되는 법칙입니다. 사실 이전 글에서 봤던, 집배부 예시가 데미테르를 설명하는 가장 유명한 예시라고 합니다. 

(주의) 이번 글은 다소 원론적 일수 있습니다 ..  

#### 데미테르의 법칙   

데미테르의 법칙의 목적은 모듈들 사이 혹은, 객체 간의 관계에 있어 결합도를 줄이는 것입니다. 
OOP의 목적과도 일치하네요 :D  

데미테르를 만족시키기 위한 조건들은 다음과 같습니다. 

> 어떤 객체 o에 대해서, o의 메서드 m은 다음과 같은 객체의 메서드만을 실행시킬 수 있다. 

    1. o 자체의 메서드
    2. m의 변수
    3. m안에서 만들어진 객체
    4. o가 직접 관리하는 컴포넌트 객체
    5. m scope안에서 o가 접근 가능한 전역변수 

위 법칙을 지키면 기본적으로 Tell, Don't Ask 를 지킬 수 있고, 결합도를 어느정도 줄일 수 있다고 말합니다. 
책에서는 이를 조금더 쉽게 설명해 두었는데요. 

    1. 메서드에서 생성한 객체의 메서드만 호출
    2. 파라미터로 받은 객체의 메서드만 호출
    3. 필드로 참조하는 객체의 메서드만 호출 

입니다 ..... ~~뭐가 더 쉽다는건지 ..~~

이전 예제를 다시 끌고오자면, 

	public class PaperBoy {
	
		public void receiveOrder(Customer customer){
			int price = 1000;
			Wallet wallet = customer.getWallet();
			
			if(wallet.getTotalMoney() > price){
				wallet.subtractMoney(1000);
			}else {
				// 돈이 없습니다.
			}
		}
	}

위 코드는 데미테르 법칙을 어기고 있습니다. 파라미터로 받은 객체의 메서드만 호출해야하는데, 파라미터의 객체로 부터 Wallet객체를 반환받아 getTotalMoney()를 호출하기 때문입니다. 
만약 지갑이 아닌 주머니에서 돈을 꺼낸다거나, 카드로 결제를 진행한다고 하면 custom객체 뿐만 아니라 paperBoy 객체의 코드도 변경이 일어납니다. 이 코드는 책임이 적절히 분배되지 못한 케이스이며 변경에 열려있다고 볼 수 있습니다. 

#### 마치며   

이 처럼 접근 가능한 객체로부터 새로운 객체를 반환 받은 뒤, 그 객체로 연산을 하는 것은 결합도를 올리는 행위입니다. 
데미테르 와 Tell,Don't Ask는 이를 피하기 위한 가이드라인일 뿐, 사실 그동안 이렇게 개발을 해왔다면 굳이 (억지로)머리아프게 볼 필요는 없습니다.  
다만, 법칙의 탄생 배경과 이를 해결하기 위해 어떤 방식을 사용했는지 정도는 알아두면 좋을것 같습니다 :D

> 객체가 아닌, Static Method Factory일 경우는 객체로 호출하지 않기에 위 법칙과는 거리가 있을거라 생각됩니다. 


