---
layout: post
title:  Effective Java Rule.1
tags: Effective Study 
categories: Effective
---   



#### 들어가며...   

Effective JAVA 2판, 1장 부분을 읽다보면 다음과 같은 글귀가 있습니다.    

	1. 이 책은 완독하라고 만든 책이 아니다. 
	(필요한 부분들만 읽을 수 있도록 챕터간의 의존성이 없다.)
	2. 성능에 대해서는 다루지 않으며, 유연성 ... 등을 다룬다.     


이 책은 말그대로 JAVA 언어를 효율적으로 다룰 수 있는 방법들에 대해 서술한 책입니다.     



#### 객체의 생성과 삭제    

이번 주에는 객체의 성생과 삭제에 대해 학습합니다.     
객체를 만들어야하는 시점과 방법, 생성을 피해야하는 경우와 방법, 적절한 순간에 객체가 삭제되도록 보장하는 방법등의 **객체의 생명주기**와 관련된 부분에 대해 학습할 수 있습니다.    


#### Rule. 1 생성자 대신 정적 팩터리 메서드 사용을 고려해라      

일반적으로 Java 및 C++등 객체 지향언어에서 객체를 생성할 때, 한번씩 거치는 메서드가 있습니다.   

`Constructor`입니다.  

그동안 편하게 사용할 수 있었고, 큰 문제없이 사용한 메서드 입니다.   
다만 책에서는 생성자를 호출하는 방식에는 크게 2가지 문제점이 존재하며, 때문에 생성자 대신 `정적 팩터리 메서드`를 사용하라고 합니다.     

> 2가지 문제점     

**메서드 명이 없다.**     

일반적으로 `가독성`이 좋다. 라고 말하는 코드는 변수 및 메서드 명으로 해당 코드가 어떤 동작을 하는지 알 수 있다는 점입니다.   

그런데, 생성자에는 이러한 메서드 명이 없습니다.    

단순히 생성자가 2개 정도라면 코드를 읽는데 큰 문제는 없습니다. 만약 생성자가 4개 혹은 5개 이상이라면 ?   
사용자는 메서드 원형 또는 주석을 보고 어떤 의미인지 `해석`해야 합니다.  

> 물론 IntelliJ에서는 Parameter 명을 보여주긴하는데 ...   

즉, 가독성이 좋은 코드라고 볼 수 없습니다.  


**Method Signature 문제**   

Java 에서 Method Signature는 Method Name, Parameter Type 입니다.   
특정 Class의 생성자들은 모든 Method Name이 같기 때문에 Parameter Type만으로 Overloading이 진행됩니다.    

	public Constructor(String userName) { } 
	public Constructor(String productName) { } 
  
네. 위 코드는 정상적으로 작동하지 않습니다.  
결국 Parameter를 추가해서 default 값을 주거나, Setter 등을 이용해서 진행해야되는데 마찬가지로 가독성 측면에서 좋지 않은 효과를 불러일으킵니다.   


위와같은 문제점들을 보완하기 위해 Effective Java에서는 `정적 팩터리 메서드`를 사용하라고 합니다.   

> 주의할 점은, Factory Method 와는 다르다고 합니다.    


`Static Factory Method`... 말로 설명하는 것보다 코드를 보여주는게 좋겠네요.   

	// 대표적인 Static Factory Method는 .valueOf 입니다. 
	Boolean flag = Boolean.valueOf(true);
    
	// 구현 부      
	public static Boolean valueOf(boolean b) {
        return (b ? TRUE : FALSE);
    }

개인적으로 `Static Factory Method`는 객체를 반환하는 Static 메서드라고 생각합니다.   

	객체를 반환하는 Static 메서드 

추가설명을 하자면, 호출때마다 반드시 새로운 객체를 생성하는 생성자와는 달리 내부적으로 객체를 들고 있으면 별도의 객체를 생성하지 않는 메서드입니다.    

**매번 객체를 생성할 필요는 없다.**

기존 생성자에 비해 추가적인 특징은 `매번 객체를 생성할 필요는 없다.` 입니다.    

> 경량 패턴과 유사하다고 하네요.     

	Flyweight Pattern의 컨셉은 이미 만들어져있는 Instance를 사용할 수 있으면,
	그것을 공유해서 사용하는 것.

싱글톤으로 만들 수도 있으며, 어떤 시점에 몇개의 객체가 존재하는지 제어도 할 수 있습니다.

> 이를 **개체 통제 클래스** 라고 부릅니다. 이 부분은 앞으로 나올 여러 규칙과 연관되어 있습니다.     

	Rule.3 ,Rule.4, Rule.15  ...

책에서 나온 말을 그대로 사용하자면, 개체 통제 클래스를 사용할 경우, **싱글톤 패턴**을 따르게 할 수 있고, **객체 생성이 불가능한 클래스**를 만들 수 도 있습니다. 또한 **변경 불가능한 클래스** 인 경우, 두 개의 같은 객체가 존재하지 못하도록 할 수 도 있습니다.    

> 이 부분에 대해서는 뒷 부분에서 학습하도록 하겠습니다.    



**반환값 자료형의 하위 자료형 객체를 반환 할 수 있다.**   

개인적으로 해당 특징을 곱씹어봤을 때, Factory Pattern 처럼 쓸 수 있다 로 해석 할 수 있습니다.  

즉 상속 관계 및 구현 관계에 있을 때, 부모 클래스에서 자식 객체를 반환 할 수 도 있습니다.  

	public static Parents initFactory(String type){
		if(type.eq("A")){
			return new ChildA();
		}else{
			return new ChildB();
		}
	}
  
> 개인적으로 Factory + Strategy Pattern 을 합쳐서 사용해 왔으며, 정적 팩토리 메서드를 사용해서 이를 구현할 수 있습니다.     

책에서 이 방법은 Interface-based framework 구현에 적합하다 라고 언급을 하고 있습니다.    

(사실 이 부분은 아직 이해는 안가는데, 18장 까진 읽어봐야 할거 같다.)   

> 사용하는 사용자가 실제 구현체를 코드를 바라보는 것이 아닌, Interface를 바라보고 개발을 진행 할 수 있는 것.     

라고 개인적으로 이해하고 있습니다. 

또한 이게 가능하다면, 실제 구현코드를 private으로 숨기고, 각기 다른 방식(알고리즘)으로 해당 Interface를 구현할 수 있습니다.   
즉, Client는 내부 동작을 이해할 필요가 없을 뿐더러 나아가 어떤 Class에 의해 수행되는지 몰라도 사용가능하게 됩니다.     

	Map map = Collections.synchronizedMap(new HashMap<>());  

한가지 예시로, 우리는 위 코드가 어떻게 동작하는지 몰라도, Thread Safe한 Map을 반환하는걸 알 수 있습니다.   

> 물론 실제 사용한다 라고 했을 때는 내부 로직을 봐야할 것 같지만 ...   

위 방법을 사용했을 때의 또한가지 장점은 버전관리가 쉽다라는 점입니다.   

만약 추상화 되어있지 않은 상태의 로직을 제공하다가 , 해당 로직에 변경이 일어나면 Client는 해당 코드를 고쳐야하는 번거로움과 버전관리,  하위 호환성이 깨질 수 있다는 문제점이 존재합니다.    

책에서 설명하는 예시로는 `EnumSet` 규칙이 있는데, 얘를 내부적으로 살펴보면 꽤 재밋는 로직을 볼 수 있습니다.   
 
> 이 부분은 코드로 보여주는 걸로 ...   

설명 할 것들
	
	1. EnumSet의 내부적인 생성 방법 
	2. EnumSet의 존재 이유  


서비스 제공자 프레임워크라는 말이 나오는데, 이건 아직 이해하기 어려워서, 추후 시간이 될떄 정리를 해서 Yobi에 올리겠습니다.  

간단하게 설명하면, 실제 구현코드가 설계 시점에서 구현되어 있지 않아도 사용할 수 있도록 구조를 만드는 방법같은데 .. JDBC 같은 애들이 이런 프레임워크 구조로 설계 되어있다고 합니다.   

(이번 주 내로 정리해서 올리도록 하겠습니다. )

~~형인자 자료형 객체를 만들 떄 편하다.~~    

> 이 부분은 Java 1.7 부터 지원하므로 Skip   

  
#### 단점   

	1. 정적팩터리 메서드만 있는 Class 인 경우
	2. 다른 정적 메서드와 구분 되지 않는다.    



> 정적 팩터리 메서드만 있는 Class 인 경우    

정적 팩터리 메서드만 있는 경우의 문제점은 하위클래스를 만들 수 없다는 점입니다. 또한 정적 팩터리 메서드가 반환하는 private class도 마찬가지입니다.

이는 inheritance 대신 composition 기법을 쓰도록 장려한다는 이유에서 더 좋다는 의견도 있습니다.    

> 다른 정적 메서드와 구분 되지 않는다.    

사실 이 부분은 주석등을 통해 구현되는데, 일반적으로 정적 팩터리 메서드 패턴에 사용되는 함수명들이 존재합니다.    

	Of , valueOf , newInstance ....    



2017 .12 .17      
**Rule.1 생성자 대신 정적 팩터리 메서드 사용을 고려해봐라**    
lusiue@gmail.com      

    
 


