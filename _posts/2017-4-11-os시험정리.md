---
layout: post
title: os 1장 
tags: 
categories: 학교
---

중간고사 정리본

### 컴퓨터 시스템의 개요 

##### 하드웨어 구성요소 

1. 처리기
    
	처리기는 레지스터와 ALU 제어장치로 구성되어 있음.

2. 주기억장치    

	주기억장치는 휘발성 !    
	데이터와 프로그램을 저장하며 CPU가 모든 주소를 바로 지정함.	 
3. 저장장치     

	비휘발성  EX 디스크 

4. 통신장치    

	네트워크 모듈 이런거 
 
5. I/O 장치 


> 컴퓨터 하드웨어는 처리기, 주기억장치 , 저장장치, I/O모듈 장치 , 통신 장치로 구성되어 있다.    


#### 처리기 외부 입출력용 레지스터

MAR 과 MBR 이 존재 . 


MAR은 다음번에 쓰거나 읽을 주소를 저장하고 있음.

**MBR은 메모리로 부터 쓰거나 가져온 데이터를 포함.**

#### 프로세서의 발전     

마이크로 프로세서란 ?  

초기에는 단일 칩에 하나의 프로세서를 집적,  현재는 단일칩에 코어라 불리는 여러개의 프로세서를 포함하고 있다.    

GPU    

고급 그래픽 랜더링에 사용됨 .     

DSP    

오디오와 비디오같은 Stream형 신호처리 

SOC     

전체 시스템이 하나의 칩에 내장 


> 마이크로프로세서와 GPU , DSP , SOC 가 존재 .   


#### 명령어 실행 2단계   

1. 반입 

 처리기가 메모리로부터 명령어를 읽는다.  >     
	 pc가 다음에 읽을 명령어 주소를 저장.  

> pc에서 실행할 명령어를 가져온  후, pc를 증가시킨다. 
   
2. 수행    

반입된 명령어를 수행한다.   


명령어 레지스터 (IR)    

IR은 현재 수행중인 명령어 주소를 저장한다.   
반입된 명령어 주소는 IR에 저장되고 
PC는 다음번 실행 할 명령어의 주소를 갖고있는다.   

명령어의 4가지 범주 .

처리기 <-> 메모리 / I/O     
데이터 처리    
제어     



#### Interupt ?    
   
대부분의 I/O 디바이스는 처리기보다 속도가 느림.    
처리기는 디바이스의 작업완료까지 기다리는 경우가 발생함.    
즉 , 기다리는 동안 처리기가 일을 안함.    

이러한 문제를 해결하기위해, I/O 디바이스가 작업완료 후, 처리기에게 
Interupt를 걸수 있도록 설계. -> 그동안 처리기는 다른 일을 할 수 있다.    

처리기는 명령어 실행 단계 마지막에서 Interupt 발생 여부를 체크함    

> interupt가 존재할 경우 멈추고 처리, 없으면 다음 명령어 반입.    

Interupt가 발생시, ISR를 실행.   

문제는 CPU가 interupt가 있는지 확인해야만 함. Overhead 발생. 

> I/O 처리동안 처리기가 다른 일을 할 수 있도록 I/O는 작업 완료시 interupt를 날림.   
> 단, 처리기는 interupt가 있는지 매번 체크해야 하므로 overhead가 발생 함.


#### Interupt의 종류   
순차적 인터럽트 / 중첩 인터럽트가 있음.    

1. 순차적 인터럽트

	우선순위 및 시간 긴급도를 고려하지않음.    
	하나의 인터럽트 처리중에는 다른 인터럽트 불능화.   
     
2. 중첩 인터럽트

	Interupt 간 우선순위를 부여.    
	낮은 Interupt 수행중에 높은 interupt가 들어오면 높은 interupt 시작가능.	


> 순차적 인터럽트는 우선순위를 고려하지않고 들어온 순서대로 처리함.     
> 중첩 인터럽트는 우선순위를 고려하며, 높은 interupt가 들어오면 새롭게 실행 할 수 있음.   


#### 입출력 관련 통신기술    

1. 프로그램된 입출력     

	처리기는 I/O연산이 끝날때 까지 I/O 모듈의 상태를 주기적으로 체크한다.    

	I/O 모듈은(S/W) 행위를 수행하고 나서, I/O 상태 레지스터에 관련 비트를 설정하고 처리기는 계속해서 비트를 확인해야한다.	
    
	POLLING -> Overhead 발생   

2. Interupt 구동 입출력    

	I/O 모듈이 처리를 끝내면 처리기에게 Interupt를 보내는 방식.    
	Interupt를 받으면 처리기는 문맥을 저장하고 ISR을 실행.   
	
> 문맥이란 현재 수행중인 상태를 의미한다.    

	Interupt 구동 방식은 처리기가 인터럽트에 깊게 관여한다는 단점이 있다.   

3. DMA     

Direct Memory access  

처리기와 I/O 모듈사이에서 데이터 블록을 직접 전송 
이때 처리기가 간섭하지 않음    

#### 메모리 계층구조    

접근시간이 빠르면 비용이 증가    
용량이 클수록 비트당 저장 비용이 감소   
용량이 크면 접근속도는 느림  

> 계층 구조를 내려가면서    
> 비트당 비용감소 , 접근속도 감소 , 용량 증가 , 처리기 접근 빈도가 줄어듬     


#### 참조 지역성    

처리기의 메모리 참조는 인근 지역으로 몰리는 경향이 있다.    

지역성에는 시간 지역성과 공간 지역성이 있다.

시간 지역성은 한번 불린 데이터가 근 시일내로 또다시 불린다. (반복문)    

공간 지역성은 한번 불린 데이터 인근에 데이터가 또다시 불릴수 있다. (배열)     


> 이러한 참조 지역성을 특징을 이용해서 캐싱을 구성함.   


#### 캐싱    


(메모리 계층구조) 빠른 저장 장치에 최근 접근한 데이터를 저장하는 기법.    
( 데이터 일치성의 문제가 존재함. )   

###### 캐시 원칙    

참조 지역성 때문에 최근 불릴 데이터를 캐시에 존재할 가능성이 있음.
때문에 처리기는 캐시를 먼저 참조한다.   
캐시에 데이터가 없을 시, 해당 데이터 블록을 캐시에 저장해둠.     

> 캐시는 OS에 보이지 않고, CPU 및 MMU가 전담한다. 
> SRAM을 사용함.   


+ 디스크 캐시  메인메모리 일부를 이용하여  디스크에 저장된 데이터 일부를 일시적으로 저장하기 위해 사용.   


캐시 설계시 고려사항  

> 캐시의 크기, 블록의 크기 , 매핑함수 , 교체알고리즘, 쓰기 정책 , 캐시 단계수  
> 매핑함수란 블록이 캐시의 어느위치에 저장되는지 결정  


##### 병행성과 병렬성    

병행성은 CPU가 한개    

병렬성은 CPU가 여러개 ..   

병렬성에는 SMP , 클러스터 (네트웤) ....

#### SMP 란    
두개이상의 유사한 프로세서로 구성됨    
이 친구들은 하나의 통합된 OS에 의해 제어.     

주기억장치와 I/O 장치를 공유하며, 프로세서들이 메모리로 접근하는 시간이 거의 비슷하다. => 
모든 처리기는 동일한 수행을 할 수 있다.    

장점으로는 성능과 가용성, 점진적 확정 , 크기 조정 등이 있다 .     

성능 = > 2개 이상의 유사한 프로세서로 이루어지기에, 동일 타입의 단일 프로세서에 비해 성능이 좋음 .   

가용성 => 여러개의 프로세서로 구성되어, 하나의 프로세서에 문제가 생기더라도 동작이 가능함.   

점진적 확장 - > 프로세서를 추가적으로 늘릴 수 있다.   

크기 조정 - > 밴더들은 처리기 수에 따라 성능/가격 이 다양한 제품을 낼 수 있다. 




    


##### 2 장 운영체제 개요    

목적 :: OS 전체 개념 용어를 정리하고 발전과정에 대한 설명     


OS란 무엇인가 ?    

HW와 응용프로그램 간의 인터페이스 .    
응용프로그램의 실행을 제어하는 프로그램.      

> HW와 응용프로그램 간의 인터페이스.       
> 컴퓨터 사용자와 응용프로그램간의 중개자 역할을 함.   

운영체제의 목적 3가지    

> 편리성 효율성 발전성     

운영체제는 2가지 관점이 존재한다.    

사용자 관점과 시스템 관점     

사용자 관점은 
	사용자와 컴퓨터간의 인터페이스    

> (편리성)  사용자가 편하게 사용 가능 

시스템 관점은    
	자원 관리자로서의 운영체제    
       
> (효율성)    

운영체제는 프로그램개발 , 실행 , I/O 디바이스 접근 등의 서비스를 제공한다.



#### OS 계층구조    

1. 커널     

	커널이란 주기억장치에 상주되는 OS의 핵심파일로, 메모리관리 프로세스관리 등의 역할을한다.

2. 쉘     

	사용자와 커널사이의 중개자 역할을 하는데, 명령어를 해석해서 커널로 넘긴다.   	

3. 파일시스템

	컴퓨터 정보관리 ...

4. 유틸리티/명령어   

	파일편집기, 프로그래밍 ... 

> OS는 커널 , 쉘 , 파일시스템 , 유틸리티 / 명령어 의 계층구조를 갖는다.   


#### OS 서비스 종류      

1. 부팅서비스     

	컴퓨터가 시작될때 OS를 주기억장치에 초기화한다.

2. 사용자서비스    

	프로그래머가 프로래밍을 손쉽게 수행 할 수 있도록 제공되는 서비스    
	gui, 파일조작 ...     	

3. 시스템서비스     

	시스템 자체의 **효율적인 동작**을 보장    
	자원할당 , 계정  ...

	ex) 여러사용자들에게 컴퓨터 자원을 공유하여 효율성을 높일 수 있음.

4. System Call 서비스     

	실행중인 프로그램과 OS간의 인터페이스, 이를 이용하여 os의 기능을 서비스받는다.   
	API라고도 함.     


> OS의 서비스 종류는 부팅서비스, 사용자서비스, 시스템 서비스 , 시스템 콜 서비스 가 존재.     


#### OS의 발전과정    

1. 순차처리     
	
	이때는 아직 os가 없음.    
	사용시간을 예약해야 했고, 준비시간이 길다.      
	(컴파일러 적재 , 프로그램 적재 ... 등등 )
	
> 스케줄링과 준비시간등이 많이 소요됬음.    
	

2. 단순 일괄처리    

	모니터라는 SW가 존재했고, 항상 주기억장치에 상주하여, 일련의 이벤트를 제어했다. 
	JCL 이라는 언어로 된 명령어로 작동됬고, 작업이 끝나면 제어가 모니터로 넘어가고 
	모니터는 다음 작업을 읽었음.    
	작업의 결과는 출력되어 사용자에게 보여짐.     

> 모니터라는 SW가 항상 주기억장치에 상주하여 일련의 이벤트를 제어했다.   

3. 멀티 프로그래밍 일괄처리    

	단일 프로그램의 경우 I/O 요청시 결과가 올 때 까지 기다려야했다.
	때문에 Overhead가 발생했고 이를 보완하기위해 
	I/O	발생시 처리기 제어를 다른작업으로 넘기는 멀티 프로그래밍이 등장.   

> 여러 프로그램들이 메모리에 올라와 cpu를 돌아가면서 사용한다.     	
> **CPU의 이용률 극대화가 목표.  **  
> 수행중인 job과 상호작용이 안된다 ?    

4. 시분할    

	처리기 시간을 여러 사용자들이 공유.     
	다수의 사용자들이 터미널을 통해 동시에 시스템에 접근한다.    

> 처리기 시간을 여러 사용자들이 공유함    
> 응답시간 최소화가 목적 


> 순차처리 시스템, 단순 일괄처리시스템, 멀티프로그래밍 일괄처리 , 시분할 

+ 버퍼링과 스플링     

버퍼링과 스플링은 I/O 시간을 줄이기 위한 방법이다.    

버퍼란   

I/O 장치와 CPU 사이의 시간을 줄이기 위해 사용되는 기법으로
주기억장치에 버퍼라는 공강을 두어 한꺼번에 여러 레코드들을 모아서 입출력하는 방식.        
단일 작업에 대한 입출력을 처리한다.   

> 주기억장치에 버퍼라는 공간을 둠. 여러 레코드들을 모아서 입출력.    

스풀링이란    

주기억장치에 공간을 모아서 입출력하는 버퍼와는 달리 스풀링은 디스크에 여러 레크드들을 모아서 입출력한다.      
또한 일반적으로 여러 작업에 대한 입출력을 처리한다.
 
> 디스크에 공간을 두고, 여러 작업에 대한 입출력처리.    


#### OS의 주요성과    

#### 프로세스관리     

프로세스는 **타이밍과 동기화를 관리하기 위해서 탄생**했다.   

OS의 오류의 주요 원인은 

	**부적절한 동기화 **   
	(잘못설계된 신호 주고받기 메커니즘은 데이터를 잃거나 중복될 수 있음)
	비결정적인 프로그램 실행   
	(프로그램의 스케줄링 순서에 따라 결과가 달라짐)
	교착상태    
	(두 프로세스가 서로의 결과를 대기하고 있는 상태)
	**상호배제 실패  **
	(여러프로그램이 동시에 공유자원을 사용하려 시도한경우)

> 프로세스는 데이터와 프로그램 문맥으로 구성되어 있으며    
> 프로세스 목록에 프로세스를 등록한다.   
> OS는 이 목록을 참고하여 실행하려고 하는 프로세스를 호출한다.   

2. 메모리관리      

**가상메모리**
      
실제 메모리크기와 상관없이 논리적 관점에서 메모리 주소를 지정할 수 있다.

**Paging **   

**프로세스 메모리**를 페이지라는 고정크기 블록단위로 관리함.    
+ 세그먼트는 가변길이 

3. 정보보호와 보안    

> 가용성 , 기밀성, 무결성, 신빙성 

4. 스케줄링과 자원관리      

> 공정성, 반응시간 차등, 효울성    

####  OS로의 발전    

#### 마이크로 커널 구조 

기본 핵심 기능만 커널에 구현, 나머지는 서버라는 프로세스로 제공     
> 서버 프로세스는 사용자모드에서 수행되며, 일반 응용과 동일한 수준.     

##### 멀티 스레딩    

프로세스를 여러개의 스레드 형태로 나누어 병행적으로 실행시키는 기법 .      


#### SMP    

유사한 성능을 지닌 2개이상의 프로세서로 구성됨.    

가용성, 성능, 점진적 확장, 크기 조정등의 장점이 있다.   

> I/O장치와 주기억장치는 공유되어 사용    
> 프로세서들은 하나의 OS에 의해 제어 


##### 분산 운영체제

(클러스터 )   

##### 객체지향 설계   

(모듈)   


##### 결합 허용    

HW/SW 고장에도 불구하고 시스템, 컴포넌트가 계속 정상작동 할 수 있는 능력.   
> 신뢰성을 보장하기 위함

어느정도의 여분의 설비가 동반되고, 비용가 성능에 손해가 발생.   

#### 영구적 / 일시적     

영구적 :: 한번 고장나면 새것으로 교체되거나 수리하기 전까지 계속 결함이 발견된 채로 있음 .   

일시적 :: 모든 동작과정에서 항시 나타나지는 않음.    

단발적과 간헐적이 있음.   

단발적은 한번 발생하고 마는 유형.    

간헐적은 예상할 수 없는 시점에서 수차례 발생.   


####OS의 결함 허용 기법

1. 프로세스 분리 
2. 병행성 제어
3. 가상기꼐
4. 체크포인트와 롤백    




 