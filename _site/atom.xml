<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Jang chulwoon</title>
 <link href="http://localhost:8080/atom.xml" rel="self"/>
 <link href="http://localhost:8080"/>
 <updated>2016-12-21T11:59:55+00:00</updated>
 <id>http://localhost:8080</id>
 <author>
   <name></name>
   <email>ㅣlusiue@gmail.com</email>
 </author>

 
 <entry>
   <title>[Web]RESTful? </title>
   <link href="http://localhost:8080/2016/12/19/REST.html"/>
   <updated>2016-12-19T10:32:00+00:00</updated>
   <id>http://localhost:8080/2016/12/19/REST</id>
   <content type="html">&lt;blockquote&gt;
  &lt;p&gt;Spring을 혼자 독학 하셨다고 했는데,  &lt;br /&gt;
본인이 생각하기에 RESTful의 가장 큰 특징 (장점)이 무엇인거 같나요 ?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;오늘 면접에서 받은 질문입니다.  &lt;br /&gt;
긴장을 있어서 자세히 기억은 나지 않지만, 이렇게 답했습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;데이터 타입에 제약을 받지 않습니다.    &lt;br /&gt;
.xml 및 .json 등 한 URI로 여러 타입의 데이터를 받을 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;…………..ㅎ  &lt;br /&gt;
그래서 오늘은 RESTful에 대해 간단히 정리해보도록 하겠습니다.   &lt;br /&gt;
자세한 내용은 &lt;a href=&quot;http://bcho.tistory.com/953&quot;&gt;조대협의 블로그&lt;/a&gt;을 참고했습니다.   &lt;br /&gt;
예시는 제가 그동안 사용한 방식과 RESTful의 방식을 비교하며 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;restful---&quot;&gt;RESTful 탄생 , 개념&lt;/h1&gt;

&lt;p&gt;REST란 &lt;strong&gt;RE&lt;/strong&gt;presentational &lt;strong&gt;S&lt;/strong&gt;ate &lt;strong&gt;T&lt;/strong&gt;ransfer의 약자로, 직역하면 표현 상태의 변경입니다.  &lt;br /&gt;
REST는 HTTP의 창시자 중, Roy Fielding의 논문에 소개되었습니다.   &lt;br /&gt;
현재 웹 아키텍쳐가 HTTP본래의 설계 우수성을 많이 사용하고 있지 못하다고 판단하여, 장점을 최대한 활용 할 수 있는 네트워크 기반의 아키텍쳐(REST)를 소개했습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;REST 란 Client 와 Server 간에 HTTP의 장점을 이용하여 자원을 주고 받는 방식입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;조금 더, 깊게 들어가보겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;구성&lt;/h1&gt;

&lt;p&gt;REST는 HTTP URI + HTTP Method로 구성되어있습니다.  &lt;br /&gt;
URI(자원의 위치)로 대상 자원을 명시하고, Method로 행위를 정의하고, 추가적으로 필요하다면 메세지(Payload)도 함께 전송합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;HTTP Method의 &lt;strong&gt;post, get , put , delete&lt;/strong&gt; 등을 이용하여 자원의 &lt;strong&gt;CRUD&lt;/strong&gt; 행위를 지정합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;정리하자면,  REST는 요소는 다음과 같습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;자원 (URI)&lt;/li&gt;
  &lt;li&gt;행위 (HTTP Method)&lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;메세지 (Payload)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;REST는 &lt;strong&gt;URI + HTTP Method + payload&lt;/strong&gt; 로 구성됩니다.  &lt;br /&gt;
URI는 자원을 표현해야하며, 행위는 &lt;strong&gt;HTTP Method&lt;/strong&gt;로 표현됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section-1&quot;&gt;예시&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jangchulwoon.github.io/&lt;/code&gt;라는 도메인에서 jcw에 대한 회원 정보를 가져오고 싶다면 다음과 같이 표현합니다.&lt;/p&gt;

&lt;p&gt;(제가 사용하고 있는 표현) &lt;br /&gt;
URI :  jangchulwoon.github.io?users=jcw  &lt;br /&gt;
Method : GET&lt;/p&gt;

&lt;p&gt;(RESTful 표현)   &lt;br /&gt;
URI :  jangchulwoon.github.io/users/jcw   &lt;br /&gt;
Method : GET&lt;/p&gt;

&lt;p&gt;두 방식의 다른점이 보이지만, 위 예시에선 큰 차이를 느끼지 못했습니다.&lt;/p&gt;

&lt;p&gt;다른 예시를 들어보겠습니다.&lt;/p&gt;

&lt;p&gt;(제가 사용하고 있는 표현)   &lt;br /&gt;
URI :  jangchulwoon.github.io/update?user=jcw    &lt;br /&gt;
Method : GET&lt;/p&gt;

&lt;p&gt;jcw라는 사용자의 정보를 수정하는 표현입니다.&lt;/p&gt;

&lt;p&gt;지금까지 진행한 프로젝트들은 GET,POST만을 이용하여 CRUD를 표현했습니다.  &lt;br /&gt;
(Update와 delete도 GET,POST 만을 사용했죠 )&lt;/p&gt;

&lt;p&gt;위 방식이 HTTP를 사용하면서 설계원칙을 전혀 지키고 있지 않다고 판단,  REST는 이 같은 문제를 해결하기위해 등장했습니다.&lt;/p&gt;

&lt;p&gt;HTTP 설계 원칙을 지킨다면 다음과 같이 사용되겠죠.&lt;/p&gt;

&lt;p&gt;URI :  jangchulwoon.github.io/user/jcw    &lt;br /&gt;
Method : PUT &lt;br /&gt;
payLoad  {
	name : 변경 할 내용 
}&lt;/p&gt;

&lt;p&gt;HTTP Method 중 정보를 update 하는 Method 인 put을 사용하고  &lt;br /&gt;
URI에는 행위에 해당하는 부분(update)이 포함되지 않아야 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;다음과 같이 URI는 자원을 표기하고, Method는 알맞는 행위를 표현해야합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;[부록] HTTP Method&lt;/p&gt;

    &lt;p&gt;HTTP프로토콜에 정의된 4개의 메소드들이 자원에 대한 CRUD를 정의합니다.&lt;/p&gt;

    &lt;p&gt;POST : Create  &lt;br /&gt;
  GET : Select   &lt;br /&gt;
  PUT : Update   &lt;br /&gt;
  DELETE : Delete&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-2&quot;&gt;특징&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;유니폼 인터페이스(Uniform Interface)&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;HTTP 표준에만 따른다면, 어떠한 플랫폼 및 언어에 종속받지 않고 사용 할 수 있는 &lt;strong&gt;느슨한 결합형태&lt;/strong&gt;의 구조이다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;무상태성/스테이트리스(Stateless)&lt;/p&gt;

    &lt;p&gt;HTTP는 기본적으로 상태 정보를 유지하고있지 않는 Stateless 이다.   &lt;br /&gt;
 ( 상태 정보를 갖고있지 않기에 캐쉬 및 Session을 이용하여 login등을 처리한다.  )&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;마찬가지로 REST를 사용할 경우, 세션과 같은 컨텍스트 정보를 신경쓸 필요가 없기 때문에 구현이 단순해진다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;캐싱 가능(Cacheable)&lt;/p&gt;

    &lt;p&gt;REST의 가장 큰 장점은 HTTP를 사용하기에 웹에서 사용하는 기존 인프라를 그대로 활용 할 수 있다는 점이다.  &lt;br /&gt;
 HTTP 프로토콜 기반의 로드밸런스, &lt;strong&gt;SSL, 캐싱 기능&lt;/strong&gt;을 적용 할 수 있다.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;캐싱을 사용하면 응답시간 뿐만 아니라, 성능 그리고 서버의 자원 사용률을 향상 시킬 수 있다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자체 표현 구조(Self-descriptiveness)&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;API 메시지만 보고도 API를 이해할 수 있는 Self-descriptiveness 구조를 갖는다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;section-3&quot;&gt;마치며&lt;/h1&gt;

&lt;p&gt;간단하게 개념을 정립하는 수준으로 글을 정리해봤습니다. &lt;br /&gt;
이 외로도 URI에 동사보다 명사를 써야한다 던가 , REST의 설계 원칙들이 있지만 &lt;br /&gt;
관련된 프로젝트를 진행하며 차차 정리해보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;( 얼마나 이상한 대답을 했는지 되돌아 보게되는 포스팅입니다. )    &lt;br /&gt;
그동안 POST 및 GET만을 사용하여 모든 CRUD를 처리해왔는데 이 방식이 http를 완전히 활용하고 있지 못하다는 내용이네요. 정리한 내용을 프로젝트에 진행 할 수 있도록 노력해봐야겠습니다.&lt;/p&gt;

&lt;p&gt;( REST를 맹신해선 안되겠지만 ) 
시야가 넓어진 느낌입니다.&lt;/p&gt;

&lt;p&gt;추후에 HTTP에 대해 정리해보도록 하겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;참고자료&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://bcho.tistory.com/953&quot;&gt;조대협의 블로그&lt;/a&gt;      &lt;br /&gt;
&lt;a href=&quot;http://bcho.tistory.com/m/321&quot;&gt;1회 – REST 아키텍쳐에 대한 기본(DRAFT)&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;http://sonim1.tistory.com/105&quot;&gt;피와 살이 되는 블로그&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://spoqa.github.io/2012/02/27/rest-introduction.html&quot;&gt;REST 아키텍처를 훌륭하게 적용하기 위한 몇 가지 디자인 팁&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;lusiue@gmail.com  &lt;br /&gt;
2016-12-19 장철운.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>[Java] Wrapper Class 와 Boxing,UnBoxing</title>
   <link href="http://localhost:8080/2016/12/08/Wrapper.html"/>
   <updated>2016-12-08T08:32:00+00:00</updated>
   <id>http://localhost:8080/2016/12/08/Wrapper</id>
   <content type="html">&lt;p&gt;Wrapper class 와 연결된 boxing과 unboxing, 나아가 Autoboxing, 자료형에 대해 정리해볼까 합니다.&lt;/p&gt;

&lt;h1 id=&quot;primitive-type&quot;&gt;primitive type&lt;/h1&gt;

&lt;p&gt;primitive type, 다른말로는 원시타입이라고 불립니다. &lt;br /&gt;
Java는 여러가지 원시타입을 갖고있는데, 많이 사용하는 int , double, boolean, char 등이 여기에 해당합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;원시타입은 비객체 타입이며, 따라서 Null 값을 가질 수 없습니다.  &lt;br /&gt;
(int a = null; 은 사용될 수 없습니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;중요한 건 원시타입은 단순히 data이기때문에 Null값을 갖을 수 없다는 것입니다.  &lt;br /&gt;
(Null은 ‘객체가 아무것도 가르키고 있지 않다’의 표현이기에 원시타입은 갖을 수 없는 값입니다. )&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;원시형은 object가 아닙니다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;reference-type&quot;&gt;Reference Type&lt;/h1&gt;

&lt;p&gt;Reference type, 즉 참조형은 java.lang.Object을 상속 받고, &lt;br /&gt;
많이 사용하는 String,List등이 참조형에 해당됩니다.    &lt;br /&gt;
또한 Primitive type인 int , double 등의 wrapper class인 Integer , Double 등이 여기에 해당합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Java 내에서 원시형이 아닌 자료형은 Reference type으로 생각하면됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;원시형과 참조형을 읽다보면 의문점이 한가지 생깁니다.  &lt;br /&gt;
원시형의 int 와 참조형의 Integer의 차이점은 무엇이고 , 왜 분리해 두었을까 ?&lt;br /&gt;
이 내용을 알아보기전에  Boxing 에 대해 정리하겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;boxing--unboxing&quot;&gt;Boxing 과 UnBoxing&lt;/h1&gt;

&lt;p&gt;Boxing은 간단하게 말해서 int 값을 Integer 값으로 변환하는 과정입니다. &lt;br /&gt;
UnBoxing 은 Boxing과 반대로 Interger 값을 int 값으로 변환하는 과정이구요.&lt;/p&gt;

&lt;p&gt;즉, 원시형의 값을 wrapper class값으로 바꾸는걸 boxing,   &lt;br /&gt;
wrapper class의 값을 원시형으로 바꾸는걸 unboxing이라고합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Integer integer = new Integer(5); // Boxing

int a = integer.intValue(); //unBoxing
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;또한 위 예시처럼  &lt;br /&gt;
intValue() 및 doubleValue() 같이 unBoxing을 위해 method를 호출 할 필요없이,   &lt;br /&gt;
jdk 1.5 이상부터는 AutoBox 및 AutounBoxing을 지원하여 다음과 같이 사용해도 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Integer integer = 5; // AutoBoxing

int a = integer //AutounBoxing
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;wrapper-class&quot;&gt;원시형과 Wrapper class&lt;/h1&gt;

&lt;p&gt;여기서 아까의 의문을 가져오겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;원시형의 int 와 참조형의 Integer의 차이점은 무엇이고 , 왜 분리해 두었을까 ?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;사실 답은 위에서 이미 언급된 내용입니다. &lt;br /&gt;
바로 원시형은 Object가 아니라는 점이죠.&lt;/p&gt;

&lt;p&gt;Java의 API를 보다보면 다음과 같은 Method를 많이 볼 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;boolean contains(Object o);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;LinkedList Method 중 하나인데, 눈에 띄는것은 인자의 형태가 Object라는 점입니다. &lt;br /&gt;
Java 언어에서 Object는 참조형의 최상위 클래스입니다. &lt;br /&gt;
즉, 저 함수의 인자로 모든 참조형이 들어갈 수 있다는 의미입니다.&lt;/p&gt;

&lt;p&gt;(다형성과 연결되는 부분이네요. ) &lt;br /&gt;
만약 API를 디자인할때, 원시형이 쓰일 경우 int, double, boolean 등 인자 마다 Method를 정의해야합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;boolean contains(int a);
boolean contains(double b);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;반면에,  Wrapper class를 만들어 두고 인자형을 Object로 사용한다면
다음과 같이 하나의 메소드만으로 모든 참조형을 받아 처리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이러한 이유때문에 Java 언어에서는 Wrapper class를 지원한다고 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;(추가 :: 2016 - 12-10)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그럼 반대로 원시형을 안쓰고 wrapper만 쓰면되지않나 ? 라는 의문점이 생겼는데요.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;원시형을 쓰지않고 참조형인 Wrapper만 쓴다면?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;처음에 떠오른 이유는 메모리 였습니다. &lt;br /&gt;
모든 데이터를 참조형으로 선언한다면, ( 단순히 ) 비용문제가 크지 않을까?&lt;/p&gt;

&lt;p&gt;구글링을 하던 도중 SliPP의 글을 질문글을 봤는데,  &lt;br /&gt;
답변은 다음과 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Wrapper class는 == 을 사용하지 못하고, equals만 써야한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Wrapper class의 경우 equals 를 쓰거나 intValue()등을 사용해아 하므로 추가적인 비용이 발생한다는 내용입니다.&lt;/p&gt;

&lt;h1 id=&quot;caching-&quot;&gt;Caching 이슈&lt;/h1&gt;

&lt;p&gt;Integer는 참조형이지만, == 을 사용할 수 있는 범위가 존재합니다. &lt;br /&gt;
-128 ~ 127 까지의 범위에서는 사용이 가능한데, 그 이유는 Integer내부에서 static class  IntegerCache 를 통해 일정 범위를 저장해두기 때문입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static class IntegerCache {  
 	//Integer을 까보시면 정의되어있습니다.
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Integer class는 -128~ 127의 범위를 cache로 저장해둔다.  &lt;br /&gt;
때문에 해당 범위 내에선 == 를 사용 가능하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;jdk 1.5 에서부턴 AutoBoxing이 지원되어, 큰 불편함이 없지만 &lt;br /&gt;
알아두면 좋을 것같아서 정리해봤습니다. !&lt;/p&gt;

&lt;p&gt;참조 &lt;br /&gt;
[1] &lt;a href=&quot;'https://docs.oracle.com/javase/8/docs/api/'&quot;&gt;Java doc&lt;/a&gt;   &lt;br /&gt;
[2] &lt;a href=&quot;`http://hyeonstorage.tistory.com/168`&quot;&gt;[JAVA] Wrapper class 란? 그리고 AutoBoxing&lt;/a&gt;   &lt;br /&gt;
[3] &lt;a href=&quot;'http://stackoverflow.com/questions/20697868/why-we-need-wrapper-class'&quot;&gt;Why we need wrapper class [duplicate]&lt;/a&gt;  &lt;br /&gt;
[4] &lt;a href=&quot;'https://slipp.net/questions/66'&quot;&gt;자바에서 primitive type과 래퍼 클래스 중 무엇을 사용하나요?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;lusiue@gmail.com  &lt;br /&gt;
2016-12-8 장철운.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>[Java] Comparable 과 Comparator</title>
   <link href="http://localhost:8080/2016/12/06/comparator_comparable.html"/>
   <updated>2016-12-06T08:32:00+00:00</updated>
   <id>http://localhost:8080/2016/12/06/comparator_comparable</id>
   <content type="html">&lt;p&gt;Java언어에서 정렬을 돕기위해 제공되는 Comparable , Comparator Interface에 대해 정리해보겠습니다.   &lt;br /&gt;
자세한 내용은 &lt;a href=&quot;'https://docs.oracle.com/javase/8/docs/api/'&quot;&gt;Java doc&lt;/a&gt;을 참고해주세요.&lt;/p&gt;

&lt;p&gt;#Comparable&lt;/p&gt;

&lt;p&gt;Comparable Interface는 객체들을 정렬하기 위한 interface입니다. &lt;br /&gt;
Comparable을 구현하고 있는 List와 배열은 자동적으로 Collection.sort에 의해 정렬되어질 수 있고, sort에 추가적인 비교자를 필요로하지 않습니다. &lt;br /&gt;
+
만약 객체의 배열 또는 리스트를 정렬할때, Comparable을 구현하지 않고 sort Method를 호출하면 java.lang.ClassCastException 이 발생하네요.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;comparable을 구현하고 있다면 해당 객체만 Array.sort()에 인자로 넣어주면 
자동적으로 정렬이 됩니다. 자세한 내용은 예제를 참고해주세요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Comparable은 compareTo라는 Method를 갖고있는데, 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	int compareTo(T o) 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;해당 Method는 -1,0,1 의 값을 반환하는데, 반환값이 0이면 두 수가 같음을 의미하고 인자로 들어온 값이 더 크면 -1을 , 작으면 1을 반환합니다.&lt;/p&gt;

&lt;p&gt;다음은 comparable을 구현한 예제입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;```

	public class Main {
	    public static void main(String[] args){
	        Student[] students = new Student[5];
	
	        Student Jang = new Student(&quot;장철운&quot;,50);
	        Student Kim = new Student(&quot;김씨&quot;,60);
	        Student Moon = new Student(&quot;문씨&quot;,40);
	        Student Jo = new Student(&quot;조씨&quot;,80);
	        Student Pack = new Student(&quot;박씨&quot;,70);
	        students[0] = Jang;
	        students[1] = Kim;
	        students[2] = Moon;
	        students[3] = Jo ;
	        students[4] = Pack;
	
	        Arrays.sort(students);
	
	        for(Student st : students){
	            System.out.println(&quot;성적 :&quot;+st.getScore()+&quot;\t 이름 : &quot;+ st.getName());
	        }
	
	
	    }
	}
	class Student implements Comparable{
	    private int score;
	    private String name;
	
	    Student(String name, int score){
	        this.name = name;
	        this.score=score;
	    }
	    public int getScore(){
	        return score;
	    }
	    public String getName(){
	        return name;
	    }
	
	    @Override
	    public int compareTo(Object o) {
	        int input_score = ((Student)o).getScore();
	        // input_score - this.score 를 하면 내림차순으로 정렬할 수 있습니다.
	        return this.score - input_score;
	    }
	}
		

```     예제의 결과값은 다음과 같습니다. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;성적 :40	 이름 : 문씨 &lt;br /&gt;
성적 :50	 이름 : 장철운 &lt;br /&gt;
성적 :60	 이름 : 김씨 &lt;br /&gt;
성적 :70	 이름 : 박씨 &lt;br /&gt;
성적 :80	 이름 : 조씨&lt;/p&gt;

&lt;p&gt;compareTo 메소드는 if문을 사용하지 않고도 단순히 return this.score - input_score 처럼 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;+
추가적으로 Array.sort()의 동작방식이 궁금해서 찾아봤습니다 .&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;```
    public static void sort(Object[] a) {
        if (LegacyMergeSort.userRequested)
            legacyMergeSort(a);
        else
            ComparableTimSort.sort(a, 0, a.length, null, 0, 0);
    }
```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;jdk7 이상부터는 팀정렬로 , jdk6 이하 부터는 초기 합병정렬로 동작한다는 구문입니다. &lt;br /&gt;
만약 초기합병정렬로 실행하고 싶다면, 다음과 같이 환경설정을 해야합니다. 
  -Djava.util.Arrays.useLegacyMergeSort=true&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;시스템 프로퍼티로 실행할 경우엔 동작하지 않는다고 하네요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;( 정렬과 관련해선 추후 정리하도록 하겠습니다. 간단히 팀 정렬은 개선된 합병정렬과 삽입정렬의 조합으로 만들어진 알고리즘이라고합니다. )&lt;/p&gt;

&lt;p&gt;조금 더 깊게 들어가보면 다음과 같은 로직을 볼 수 있는데,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;```
        if (((Comparable) a[runHi++]).compareTo(a[lo]) &amp;lt; 0) { // Descending
            while (runHi &amp;lt; hi &amp;amp;&amp;amp; ((Comparable) a[runHi]).compareTo(a[runHi - 1]) &amp;lt; 0)
                runHi++;
            reverseRange(a, lo, runHi);
        } else {                              // Ascending
            while (runHi &amp;lt; hi &amp;amp;&amp;amp; ((Comparable) a[runHi]).compareTo(a[runHi - 1]) &amp;gt;= 0)
                runHi++;
        }
```    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;scomparable을 이용하여 정렬되는 걸 볼 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;요약하면, comparable은 compareTo(T o) Method를 구현해야하고, 구현한 배열과 리스트는 Collection.sort 시 추가적인 기준을 제시하지 않아도 자동적으로 정렬 할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;#Comparator&lt;/p&gt;

&lt;p&gt;Comparable과 마찬가지로 객체들을 정렬하기 위한 Interface입니다. &lt;br /&gt;
Comparator 또한 다음과 같은 Method를 구현해야 합니다. &lt;br /&gt;
( Comparable과 달리 인자를 2개 받는 Method 입니다. )&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;```
	int compare(T o1, T o2)
```     우선 Comparator 의 예제를 보여드리겠습니다.

```
	public class Main {
	    public static void main(String args[]){
	        Student[] students = new Student[5];
	        Student Jang = new Student(&quot;장철운&quot;,50);
	        Student Kim = new Student(&quot;김씨&quot;,60);
	        Student Moon = new Student(&quot;문씨&quot;,40);
	        Student Jo = new Student(&quot;조씨&quot;,80);
	        Student Pack = new Student(&quot;박씨&quot;,70);
	
	        students[0] = Jang;
	        students[1] = Kim;
	        students[2] = Moon;
	        students[3] = Jo ;
	        students[4] = Pack;
	        Arrays.sort(students, new StudentCompare());
	
	        for(Student st : students){
	            System.out.println(&quot;성적 :&quot;+st.getScore()+&quot;\t 이름 : &quot;+ st.getName());
	        }
	    }
	
	}
	class StudentCompare implements Comparator&amp;lt;Student&amp;gt; {
	
	    @Override
	    public int compare(Student o1, Student o2) {
	        return o1.getScore() - o2.getScore();
	    }
	}
	class Student{
	    private int score;
	    private String name;
	
	    Student(String name, int score){
	        this.name = name;
	        this.score=score;
	    }
	    public int getScore(){
	        return score;
	    }
	    public String getName(){
	        return name;
	    }
	}

```    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Comparable의 예제와 비교했을 때 차이점 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;클래스 내에서 정렬 기준을 설정   (comparable) / sort(객체) &lt;br /&gt;
외부에서 정렬 기준을 설정  (comparator) / sort(객체,comparator)&lt;/p&gt;

&lt;p&gt;만약 comparable의 기준이 아닌 comparator 의 기준으로 정렬하고 싶다면 &lt;br /&gt;
sort(객체,comparator)을 사용하여 정렬이 가능합니다.  &lt;br /&gt;
사용 예시는 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;```
	public class Main {
	    public static void main(String[] args){
	        Student[] students = new Student[5];
	
	        Student Jang = new Student(&quot;장철운&quot;,50);
	        Student Kim = new Student(&quot;김씨&quot;,60);
	        Student Moon = new Student(&quot;문씨&quot;,40);
	        Student Jo = new Student(&quot;조씨&quot;,80);
	        Student Pack = new Student(&quot;박씨&quot;,70);
	        students[0] = Jang;
	        students[1] = Kim;
	        students[2] = Moon;
	        students[3] = Jo ;
	        students[4] = Pack;
	
	        Arrays.sort(students);
	        System.out.println(&quot;comparable&quot;);
	        for(Student st : students){
	            System.out.println(&quot;성적 :&quot;+st.getScore()+&quot;\t 이름 : &quot;+ st.getName());
	        }
	
	        System.out.println(&quot;comparator&quot;);
	        Arrays.sort(students,new StudentCompare());
	        for(Student st : students){
	            System.out.println(&quot;성적 :&quot;+st.getScore()+&quot;\t 이름 : &quot;+ st.getName());
	        }
	        
	    }
	}
	
	class Student implements Comparable{
	    private int score;
	    private String name;
	
	    Student(String name, int score){
	        this.name = name;
	        this.score=score;
	    }
	    public int getScore(){
	        return score;
	    }
	    public String getName(){
	        return name;
	    }
	
	    @Override
	    public int compareTo(Object o) {
	        int input_score = ((Student)o).getScore();
	        // input_score - this.score 를 하면 내림차순으로 정렬할 수 있습니다.
	        return this.score - input_score;
	    }
	}

	class StudentCompare implements Comparator&amp;lt;Student&amp;gt; {
	
	    @Override
	    public int compare(Student o1, Student o2) {
	        String name1 = o1.getName().toUpperCase();
	        String name2 = o2.getName().toUpperCase();
	        return name1.compareTo(name2);
	    }
	}
```     
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;결과는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;comparable &lt;br /&gt;
성적 :40	 이름 : 문씨 &lt;br /&gt;
성적 :50	 이름 : 장철운 &lt;br /&gt;
성적 :60	 이름 : 김씨 &lt;br /&gt;
성적 :70	 이름 : 박씨 &lt;br /&gt;
성적 :80	 이름 : 조씨 &lt;br /&gt;
comparator &lt;br /&gt;
성적 :60	 이름 : 김씨 &lt;br /&gt;
성적 :40	 이름 : 문씨 &lt;br /&gt;
성적 :70	 이름 : 박씨 &lt;br /&gt;
성적 :50	 이름 : 장철운 &lt;br /&gt;
성적 :80	 이름 : 조씨&lt;/p&gt;

&lt;p&gt;예시는 comparable 시엔 score을 기준으로, comparator 시엔 name을 기준으로 정렬하였습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;즉 기존에 정렬 방식이 아닌 새로운 기준의 정렬을 행할 경우 comparator을 정의하여 사용하면 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이상 Comparator 와 Comparable의 정리를 끝내도록 하겠습니다. &lt;br /&gt;
예시를 많이두어 이해하기 쉽도록 정리해보았습니다.&lt;/p&gt;

&lt;p&gt;참고자료 &lt;br /&gt;
&lt;a href=&quot;'https://docs.oracle.com/javase/8/docs/api/'&quot;&gt;Java doc&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;'https://www.mkyong.com/java/java-object-sorting-example-comparable-and-comparator/'&quot;&gt;Java object sorting example &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;lusiue@gmail.com  &lt;br /&gt;
2016-12-6 장철운.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>[project] eclipse 이미지 업로드문제</title>
   <link href="http://localhost:8080/2016/11/29/eclipse_img.html"/>
   <updated>2016-11-29T08:32:00+00:00</updated>
   <id>http://localhost:8080/2016/11/29/eclipse_img</id>
   <content type="html">&lt;p&gt;이클립스 및 스프링(sts)를 이용하여 프로젝트를 진행하고 있습니다. &lt;br /&gt;
이미지를 업로드하는 부분을 진행하고 있는데요.
(Spring 환경에서 multipartResolver를 이용하고있습니다.)&lt;/p&gt;

&lt;p&gt;업로드하는 부분을 진행하면서, DB에 img를 넣는 것보다 img경로를 저장하는 편이 낫다는 조언을 받았습니다.&lt;/p&gt;

&lt;p&gt;DB에는 경로를 저장하고, img파일은 resources 폴더내에 저장하는 방향으로 개발을 하고있습니다.&lt;/p&gt;

&lt;p&gt;이 과정에서 File I/O를 이용하여 프로젝트내에 저장하는 부분까지는 문제가 없었으나, &lt;br /&gt;
해당 resources 폴더를 refresh 하지 않으면 img 파일을 불러올 수가 없어, 구글링을 하던 도중 해결방법을 찾았습니다.&lt;/p&gt;

&lt;p&gt;문제는 workspace에서 파일을 인식 못하기때문이라고 하네요   &lt;br /&gt;
실제 서버에 올릴때는 문제가 없다고하네요.&lt;/p&gt;

&lt;p&gt;자세한 내용은 &lt;a href=&quot;'http://okky.kr/article/245013'&quot;&gt;okky&lt;/a&gt;을 참고해주세요&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;요약   preferences-&amp;gt;General-&amp;gt;Workspace에서 상단에 refresh 체크박스 두개 체크&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;+덧&lt;/p&gt;

&lt;p&gt;**DB에는 경로를 저장하고, img파일은 resources 폴더내에 저장하는 방향으로 개발을 하고있습니다.  **&lt;/p&gt;

&lt;p&gt;이 과정에서 업로드 경로에 관해서 고민을 했는데요 ..&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;“C:\Users\lusiu\Desktop\dev_work\spring\BuskingRoad\src\main\webapp\resources\img\”;&lt;/p&gt;

    &lt;p&gt;프로젝트 경로를 따서 저장하는 방향으로 진행하고 있었습니다. &lt;br /&gt;
 다만 실제 서버에 올릴 경우, 위 경로는 의미가 없어지기에 다른 방법을 찾던 도중 sevletcontext의 getRealPath()를 발견했습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;context.getRealPath(“/resources/img/”)&lt;/p&gt;

    &lt;p&gt;sevletContext를 컨테이너에서 가져와 위와같이 사용했습니다. &lt;br /&gt;
 이렇게 사용 할 경우,   &lt;em&gt;*C:\Users\lusiu\Desktop\dev_work\spring.metadata.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps\BuskingRoad\resources\img*&lt;/em&gt; &lt;br /&gt;
 의 경로를 가져오게 되네요.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;자세한 내용은 &lt;a href=&quot;'http://androphil.tistory.com/entry/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%8C%81-Spring%EC%97%90%EC%84%9C-%ED%8C%8C%EC%9D%BC-%EC%97%85%EB%A1%9C%EB%93%9C%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%84%B8%ED%8C%85'&quot;&gt;스프링 팁 Spring에서 파일 업로드를 위한 세팅&lt;/a&gt;을 참고해주세요&lt;/p&gt;

&lt;p&gt;lusiue@gmail.com  &lt;br /&gt;
2016-11-29 장철운.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>equals 와 Hashcode [진행x] </title>
   <link href="http://localhost:8080/2016/11/15/equals_hashcode.2.html"/>
   <updated>2016-11-15T08:32:00+00:00</updated>
   <id>http://localhost:8080/2016/11/15/equals_hashcode.2</id>
   <content type="html">&lt;p&gt;Hash code에 관한 부분은 추후 공부를 더 한후 정리하도록 하겠습니다 .&lt;/p&gt;

&lt;p&gt;글 자체를 정리하는건 쉬우나 ..  머리로 이해하질 못하네요 ..&lt;/p&gt;

&lt;p&gt;lusiue@gmail.com  &lt;br /&gt;
2016-11-15 장철운.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>equals 와 Hashcode [1] </title>
   <link href="http://localhost:8080/2016/11/03/equals_hashcode.1.html"/>
   <updated>2016-11-03T08:32:00+00:00</updated>
   <id>http://localhost:8080/2016/11/03/equals_hashcode.1</id>
   <content type="html">&lt;p&gt;hashCode()와 equals() method 는 Object에 속해있는 method 입니다.  &lt;br /&gt;
Java에서 Object class 는 모든 클레스의 superclass 입니다. &lt;br /&gt;
때문에 Java의 모든 class 는 Object의 method를 구현하고 있습니다. &lt;br /&gt;
자세한 내용은 &lt;a href=&quot;'https://docs.oracle.com/javase/8/docs/api/'&quot;&gt;Java doc&lt;/a&gt;을 참고해주세요.&lt;/p&gt;

&lt;h2 id=&quot;equals&quot;&gt;equals()&lt;/h2&gt;

&lt;p&gt;equals() method 는 동등성을 비교 할 때 사용됩니다. &lt;br /&gt;
간략하게 정리하면 equals()는 다른 객체가 특정 객체와 동일한가를 구현한 method 입니다.     Java doc에서는 equals()의 설명을 다음과 같이 정리하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;The equals method implements an equivalence relation on non-null object references:&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;equals method는 null값이 아닌 object 간의 &lt;strong&gt;동치성&lt;/strong&gt;을 구현하는 method 입니다.  &lt;br /&gt;
또한 equals method를 재정의 하려 한다면, 동치성을 만족시켜야 합니다.&lt;/p&gt;

&lt;p&gt;동치성을 만족하기 위한 몇가지 특징들은 다음과 같습니다. &lt;br /&gt;
(어찌보면 당연한 내용일 수 있습니다 ..)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;재귀  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;It is reflexive: for any non-null reference value x, x.equals(x) should return true.&lt;/code&gt;    &lt;br /&gt;
null 이외의 참조값 x 에 대해 x.equals(x)는 항상 true 여야만 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;대칭     &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;It is symmetric: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.&lt;/code&gt; &lt;br /&gt;
null 이외의 참조값 x 와 y 에 대해 y.equals(x)가 true 이면 x.equals(y) 또한 true가 되야 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이적  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;It is transitive: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true. &lt;/code&gt;  &lt;br /&gt;
null 이외의 참조값 x , y ,z 에 대해, x.equals(y)가 ture를 반환하고 y.equals(z)가 ture 반환하면 x.equals(z) 또한 ture를 반환해야 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;일관  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;It is consistent: for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified.&lt;/code&gt;     &lt;br /&gt;
null 이외의 참조값 x , y 에 대해, equals를 통해 비교되는 정보에 수정이 없다면, x.equals(y)의 호출의 결과는 계속해서 true나 false여야합니다.     &lt;br /&gt;
(정보의 변화가 없다면 반환 값은 항상 일관되어져야 합니다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;null  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;For any non-null reference value x, x.equals(null) should return false.&lt;/code&gt;&lt;br /&gt;
null이 아닌 참조값 x에 대해, x.equals(null)은 항상 false 입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;코드 없이 언어로만 정리하면 당연한거 아닌가? 라는 생각이 듭니다. (저만 그런가요 ?)  &lt;br /&gt;
Java에서 어떻게 구현하고 있는지 정리해보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;object--equals&quot;&gt;Object 의 equals()&lt;/h3&gt;

&lt;p&gt;들어가기 앞서 , effective Java 에서는 equals method 를 재정의 하지 않아도 되는 경우를 다음과 같이 설명했습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;각 객체가 고유한 경우. (ex Singleton )&lt;/li&gt;
  &lt;li&gt;상위 클래스에서 재정의한 equals method가 하위클래스에서 사용하기 적절한 경우.&lt;/li&gt;
  &lt;li&gt;class가 private 또는 package-private 로 선언되있고, equals 를 호출 할 일이 없는 경우.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;논리적 동일성&lt;/strong&gt; 검사 방법이 있건 없건 상관없는 경우.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;논리적 동일성을 지원하는 클래스일 경우엔, equals를 재정의하는게 바람직하다고 말합니다. &lt;br /&gt;
( 대표적으로 Integer / Date 클래스가 이에 해당한다고 합니다. )     &lt;br /&gt;
논리적 동일성은 객체가 동일한가?가 아닌 객체 안에 있는 값이 동일한가를 의미합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위 조건 중 하나라도 만족한다면 , 재정의를 하지 않아도 됩니다. &lt;br /&gt;
(equals를 재정의할 때, 의도치 않은 오류가 생길 위험이 많습니다.  신중하게 재정의해야합니다.)&lt;/p&gt;

&lt;p&gt;object의 equals method&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	 public boolean equals(Object obj) {
        return (this == obj);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Integer의 equals method&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public boolean equals(Object obj) {
        if (obj instanceof Integer) {
            return value == ((Integer)obj).intValue();
        }
        return false;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;( Integer 는 final class 로 상속을 막아놓은 class 입니다. ) &lt;br /&gt;
Integer의 equals 를 보면 obj가 Integer type 인지 확인을 한 후, &lt;br /&gt;
맞다면, 기존 객체에 저장된 값과 넘어온 인자의 값을 비교합니다.   &lt;br /&gt;
객체의 값이 아닌 객체 안의 값을 비교하기 위해 위와같은 방식으로 equals 를 구현하였습니다.&lt;/p&gt;

&lt;p&gt;equals 와 관련이 있는 hashcode는 다음글에서 정리하도록 하겠습니다 .&lt;/p&gt;

&lt;p&gt;+&lt;/p&gt;

&lt;p&gt;Object class 의 method를 보며 ‘equals 가 재정의 되는 경우가 있나 ?’라는 궁금증이 생겨 &lt;br /&gt;
equals를 이해한 만큼 정리를 해보았습니다. &lt;br /&gt;
잘못된 부분이나 부족한 부분이 있다면 알려주세요 !  &lt;br /&gt;
(언젠가 ..? 제대로된 equals method를 작성해 보고싶습니다 .. )&lt;/p&gt;

&lt;p&gt;lusiue@gmail.com  &lt;br /&gt;
2016-11-03 장철운.&lt;/p&gt;

&lt;p&gt;참조 &lt;br /&gt;
[1] &lt;a href=&quot;'https://docs.oracle.com/javase/8/docs/api/'&quot;&gt;Java doc&lt;/a&gt;   &lt;br /&gt;
[2] &lt;a href=&quot;`http://egloos.zum.com/iilii/v/3999066`&quot;&gt;건실성실착실 3실 청년!&lt;/a&gt; &lt;br /&gt;
[3] effective Java  &lt;br /&gt;
[4] &lt;a href=&quot;'http://skylit.tistory.com/35'&quot;&gt;JAVA / OBJECT의 EQUALS와 HASHCODE 메쏘드&lt;/a&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Java-Collection[1] </title>
   <link href="http://localhost:8080/2016/10/26/Collection.html"/>
   <updated>2016-10-26T10:32:00+00:00</updated>
   <id>http://localhost:8080/2016/10/26/Collection</id>
   <content type="html">&lt;h2 id=&quot;collection&quot;&gt;Collection&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;본 글은 Java Collection Interface를 정리한 글입니다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;세부 내용은 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/&quot;&gt;Java doc&lt;/a&gt;에서 확인하세요.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Collection 이란&lt;br /&gt;
여러 객체의 그룹으로, Collection 인터페이스는 Collection 계층의 &lt;strong&gt;root interface&lt;/strong&gt; 입니다.  &lt;br /&gt;
(List / Queue Interface 등의 상위 Interface 입니다.  )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;collection의 subInterface&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;BeanContext, BeanContextServices, BlockingDeque&lt;E&gt;, BlockingQueue&lt;E&gt;, Deque&lt;E&gt;, List&lt;E&gt;....&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;일반적으로 JDK에서는 Collection 인터페이스를 직접적으로 구현하는 것을 제공하지 않고, &lt;strong&gt;Set , List&lt;/strong&gt; 같이 서브인터페이스로 구현을 제공합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;(+) Multisets은 직접적으로 인터페이스를 구현해야합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Collection을 구현하는서브인터페이스는 2개의 생성자를 구현해야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;default 생성자와 Collection Type의 단일 인자를 받는 생성자 입니다. 인자를 받는 경우 collection을 복제 할 수 있어 원하는 타입의 동등한 collection을 생성 할 수 있습니다. 이 두가지 생성자가 강요되는 것은 아니지만 모든 Java Platform Library의 Colletion Interface는 이를 준수하고 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public ArrayList(int initialCapacity) {
        if (initialCapacity &amp;gt; 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        }
    }

    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }

    public ArrayList(Collection&amp;lt;? extends E&amp;gt; c) {
        elementData = c.toArray();
        if ((size = elementData.length) != 0) {
            // c.toArray might (incorrectly) not return Object[] (see 6260652)
            if (elementData.getClass() != Object[].class)
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // replace with empty array.
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Collection의 서브인터페이스인 List를 구현한 ArrayList입니다. &lt;br /&gt;
ArrayList는 3가지의 생성자를 갖고 있는데, 그 중 2가지의 생성자는 위에서 말씀드린 생성자 입니다. &lt;br /&gt;
2번째 생성자는 collection type의 인자를 받아 복제하여 사용하는 코드입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;만약 collection이 작동을 지원하지 않는다면 UnsupportedOperationException을 던집니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;기능을 지원하지 않는 경우 발생하는 Exception&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;몇몇 collection 인터페이스는 인자에 대한 제한을 갖고 있습니다. &lt;br /&gt;
null 인자를 금지한다거나, 그들의 속성값의 제한을 합니다.&lt;br /&gt;
만약 자격이 없는 인자를 추가하려고 시도한다면 확인되지 않은 exception을 던질것입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;일반적으로 nullpointerException(null 값 문제) 이나 ClassCastException(캐스팅 문제)을 던집니다.&lt;br /&gt;
위 생성자를 보시면 collection의 인자가 Null일 경우 nullpointerException을 던진다고 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;method&quot;&gt;Method&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Java 8에 추가된 default method는 제외하고 정리해 보았습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean add(E e)   &lt;br /&gt;
Collection은 제네릭을 이용하여 선언됩니다. ( ex - List&lt;Integer&gt; list )     
해당 타입의 변수를 넘겨 받아 Collection에 추가하는 Method 입니다. ( ex - list.add(5) )&lt;/Integer&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;의미 그대로 element를 삽입하는 Method 입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean addAll(Collection&amp;lt;? extends E&amp;gt; c)
    &lt;blockquote&gt;
      &lt;p&gt;method를 정리하기 전에 (Collection&amp;lt;? extends E&amp;gt; c) 부터 정리하겠습니다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;추후 정리할 내용인 제네릭과 관련있는 부분입니다 ( ?를 &lt;strong&gt;와일드카드 타입&lt;/strong&gt;이라 부릅니다. ).   &lt;br /&gt;
class 상속받을때 쓰는 extends 의미 그대로,  &amp;lt;? extends E&amp;gt; 는 E를 상속 받은 타입을 말합니다.   &lt;br /&gt;
즉 E 의 하위타입 또는 E 타입의 인자를 받겠다는 뜻입니다.    &lt;br /&gt;
만약 &amp;lt;? extends List&amp;gt; 로 쓰인다면 List 의 하위 클래스인 ArrayList , Linked List 등의 타입이 인자로 올 수 있습니다.   &lt;br /&gt;
다만, 상위 클래스에서 정의된 메소드만 사용 할 수 있습니다.   &lt;br /&gt;
하위 클래스에서만 정의된 메소드를 사용시 에러를 낸다고합니다.&lt;/p&gt;

&lt;p&gt;(예시)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
    import java.util.ArrayList;
    import java.util.Collection;
    import java.util.List;

    interface People {
        void eat();
        void sleep();
    }

    class Student implements  People {
    
        @Override
        public void eat() {
            System.out.println(&quot;nice food  !&quot;);
        }
    
        @Override
        public void sleep() {
            System.out.println(&quot;zzzzzz !&quot;);
        }
        public void study(){
            System.out.println(&quot;studying !&quot;);
        }
    }


    public class Main {
        public static void act(List&amp;lt;? extends People&amp;gt; people){
            people.get(0).eat();
            //people.get(0).study(); 이부분은 컴파일 에러가 나옵니다.
    
        }
        public static void main(String args[]){
            List&amp;lt;Student&amp;gt; list = new ArrayList();
            Student student = new Student();
            list.add(student);
            act(list);
        }
    }   

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;다시 method 설명으로 돌아와서 , addAll method 는  인자로 받은 collection 타입의 element들을 모두 추가하는 메소드 입니다.    &lt;br /&gt;
자세한 내용은 collection을 구현하고 있는 하위 클래스를 분석하며 정리하도록 하겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;인자로 받은 collection 타입의 element를 해당 collection에 추가하는 method .&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;void clear()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;의미 그대로 해당 collection에 있는 모든 인자를 clear 하는 method 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;해당 Collection의 모든 element를 지웁니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean contains(Object o)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;인자로 받은 o 가 collection에 있으면 true를 반환. 없으면 false를 반환한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;해당 elements 가 있는지 확인하는 method .&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean containAll(Collection&amp;lt;?&amp;gt; c)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;인자로 받은 collection의 element 모두가  해당 collection에 있으면 true를 반환합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;인자로 받은 collection의 모든 element가 포함되어있는지 확인하는 method&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean equeals(Object o)&lt;/li&gt;
  &lt;li&gt;int hashCode() &lt;br /&gt;
동일성과 동등성을 체크하기위한 method . &lt;br /&gt;
Object 클래스에서 상속받아 구현하기도 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;설명 할 내용이 많기 때문에 추후 이 주제로 정리하도록 하겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean isEmpty()&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Collection이 비어있으면 true를 반환. 비어있지 않으면 false를 반환.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Iterator&lt;E&gt; iterator()&lt;/E&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Iterator 를 구현하기 위한 method . 이또한 추후 정리.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean remove(Object o)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;값을 넘겨받은 object element를 삭제하는 method&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean removeAll(Collection&amp;lt;?&amp;gt; c)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;넘겨받은 collection의 element들을 삭제하는 method.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;boolean retainAll(Collection&amp;lt;?&amp;gt; c)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;넘겨받은 collection의 element들을 유지하는 method .&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ArrayList를 찾아보며 정리하던 중 , removeAll 과 retainAll의 동작 방식이 같다는 걸 알게 되었습니다. 찾아보니 bug 라고 하더군요 … (제가 갖고있는 버전에 문제가 있던것 같습니다.)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/8372576/java-commons-collections-removeall&quot;&gt;자세한 설명&lt;/a&gt;을 참고해 주세요.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;int size()&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;collection의 size를 반환하는 메소드 입니다 . (가장 많이 접했던 method가 아닐까합니다.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Object[] toArray()&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;collection의 element들을 object 타입의 array로 변환하여 반환하는 method 입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;T&gt; T[] toArray()

&lt;/T&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
  &lt;p&gt;이전의 toArray와 같은 방식으로 array를 반환하지만, 제네릭을 사용하여 타입을 사용자가 정할 수 있다는 차이가 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;추후 Collection을 상속받은 List를 정리하면서 오늘 설명하지 못한 부분들을 정리하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;감사합니다.&lt;/p&gt;

&lt;p&gt;~ 2016 - 10 -31&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Hello? </title>
   <link href="http://localhost:8080/2016/10/20/Hello.html"/>
   <updated>2016-10-20T10:32:00+00:00</updated>
   <id>http://localhost:8080/2016/10/20/Hello</id>
   <content type="html">&lt;p&gt;Hello?&lt;/p&gt;
</content>
 </entry>
 
 
</feed>