---
layout: post
title:  You don't know Js-2
tags: JS
categories: Book
---   


#### Chapter 02 Value


이전에 읽었던 `You don't know JS` 를 다시 읽고 정리해보려합니다.

> 제가 몰랐던 것들만 정리할 뿐이라서, 책의 모든 내용을 다루진 않습니다.

잘부탁드립니다. 이전과 마찬가지로 가벼운 말투로 시작하겠습니다.

이번장에선 사실 크게 중요한 내용은 없는 것 같습니다.
Array나 숫자, String 유사배열에 대해 이야기하지만 극단적인 상황에서 js가 이렇게 행동한다 를 알려줄 뿐입니다.

때문에 윗 부분들은 넘어가고, 제가 인상깊게 봤던 부분에 대해서만 이야기하겠습니다.

주의 ) 정확하지 않은 사견이 섞여 있습니다.

#### Value copy or Reference copy

> 마지막장에 나오는 내용입니다.

	var field = 4;

	function something(param){
		param = 5;
	}

	something(field);

위 코드를 실행 시킨 뒤, field를 출력하면 뭐가 나올까 ?
정말 당연하게도, field값은 변하지 않은 4가 출력된다.

함수의 인자로 field의 주소값이나, Reference값을 넘긴게 아닌, 단순한 값을 넘겼기 때문이다.

> `something`의 param이 넘겨받은 변수의 메모리값을 바라보는게 아닌, `4`라는 값으로 초기화 된 것이다.

여기까지 봤을 때, 큰 혼란없이 `당연한거 아니야?` 라고 생각할 수도 있다.

	var arrays = [];
	function something(array){
		array.push(4);
	}

	something(arrays);

다만, 위 코드를 실행한 뒤 `arrays` 값을 출력하면 `[4]`가 출력된다.

> 이전 코드대로라면 함수로 넘긴 값에 대해 변화가 없어야되지만, 이번코드는 변했다.

조금 더 혼란스럽게 만들어보자.

	var array = []
	function something(array){
		array = [1,2]
	}

	something(array);

정말 이상하게도, 위 코드의 결과 값은 `[]`이다.
즉, 첫번째 경우처럼 원본값에는 아무런 영향을 주지 않는다.

#### Js - value copy

첫번째 경우처럼 단순 한 값을 함수로 넘길때, 동작하는 방식을 value copy라고 말한다.

> 이는 개발자가 정할 수 있는게 아닌, engine에서 값을 보고 판단한다.

(Java로 치면..) primitive type이 여기에 속한다.

> boolean, int 등 ..

primitive type들을 함수로 넘길때 저장된 메모리의 주소를 던지는게 아닌, 주소에 담긴 값을 던진다.
때문에 함수 내에서 아무리 수정을 해도 원본 값에는 아무런 영향을 끼치지 못한다.

#### Reference copy

2 / 3 번째 경우를 Reference copy라고 말한다.

> Reference 가 아니다 Reference copy 이다.

2번째와 3번째의 차이는 (개인적인 느낌) 메모리에 담긴 값을 직접 바꾸느나, 간접적으로 바꾸느냐의 차이이다.

2번째 같은 경우, object가 제공하는 함수를 이용해서 값을 수정한다.
하지만, 3번째 같은 경우 변수가 들고 있는 메모리값을 직접 수정한다.

> 만약 c++에서의 Reference	방식이였다면, 3번째 경우도 원본값이 수정되어져야한다.

c++에서 Reference를 배울 때, 이렇게 배운 기억이 있다.

	주소 값의 또다른 이름

즉, 같은 메모리 블럭을 `0101011` 같은 이진법으로 나타내는게 아닌, 사람이 알아볼 수 있는 `&변수`로 표현한 것이다.
하지만 Reference copy 방식은 메모리를 직접 가르키는게 아닌, 그 메모리를 바라보는 주소값을 말한다.

> 이 부분은 개인적으로 이해한 것이라, 정확하지 않을 수 있습니다.

즉 메모리 주소 바라보기에, 다른 object을 할당하면 그 주소만 바뀔뿐 원본 메모리는 수정되지 않는다.
2번째 같은 경우 함수를 이용해 원본 메모리의 값을 수정하지만, 3번째같은경우 바라보는 메모리의 주소값을 삭제하고 새로운 값으로 할당한다.

즉, 원본값이 아닌 새로운 값을 `바라본다.`

> 이럴 경우, 아무도 바라보지 않는 메모리가 생기는데 이를 GC가 처리한다

이런 이유로 2 번째 / 3번째 의 동작방식이 다르게 나타난다.


#### 마치며  

위 내용들은 당장 개발할 때 필요하지 않을 수 있으나, 코드가 돌아가는 방식을 이해하는데 중요한 내용들입니다.

> 실제로 위 내용을 모른다면 원치않은 결과가 나타날 수 있습니다.

평소에 어렴풋이 알았던 내용들을 제 방식대로 정리했는데요.
덕분에 저는 한결 뚜렷해진 느낌이네요 :D

감사합니다.

2018.08.16    
lusiue@gmail.com    
